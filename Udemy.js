'use strict' // Это инструкция JS более пристально наблюдать за переменными и не только.
 // Достаточно добавить первой строкой в любой код, допустим над функцией которая что-то делает.


// Колбэки и функции высшего порядка. Фундаментальный JavaScript
// Ссылка на ролик https://youtu.be/ab0a8ZbCNMY

    // 3 ключевых ПОНЯТИЯ JS.
    // Выражения const c = a + b
    // Функции function myFn(a, b) {}
    // Обьекты {}

//////////////////////////////  Переменные!!!  //////////////////////////////

// 1) Все переменные обьявлять перед их использованием.
// 2) Стараться использовать const везде, где это возможно.

// Имена переменных:

// 1) PascalCase // Типы и Классы
// 2) DB_PASSWORD // Значения известны до запуска приложения и не меняются.
// 3) camelCase // Все остальные переменные.

const j = 10 // Переменная j типа число.
const h = 10 + 5 // Выражение.


//////////////////////////////  Примитивные типы!!!  //////////////////////////////

// Тип string(строка)
// boolean(логический тип)
// number(число)
// null
// undefined (неопределенно)
// symbol (символ)

const g = 15 // Примитив
const k = 'Vlad' // Примитив

//////////////////////////////  Ссылочный Тип!!!  //////////////////////////////

// object(обьект)

//////////////////////////////  Обьекты!!!  //////////////////////////////


// Если какй-то свойство содержит функцию как значение, такое свойство называется метод!

// Обьект это набор свойст, имя: значение.
// Переменная в которую мы присваиваем обьект, содержит только ссылку на обьект а сам обьект находится в другом месте памяти.


// ПОРЯДОК СВОЙСТВ НЕ ИМЕЕТ ЗНАЧЕНИЯ!!!
const myCity1 = {
    city: 'New York',
    popular: true,
    country: 'USA'
} // свойсто city:  значение 'USA'

// ПОЛУЧАЕМ ДОСТУП К ОБЬЕКТУ!!!

console.log(myCity1.city) // New York
// Точечная запись
console.log(myCity1.popular) // true
// Точечная запись

//////////////////////////////  ИЗМЕНЕНИЕ ЗНАЧЕНИЙ СВОЙСТВА ОБЬЕКТА!  //////////////////////////////

const myCity ={
    city: 'New York'
}

myCity.city = 'Las Vegas'
// Изменяем в свойстве city значение 'New York' НА 'Las Vegas'.

console.log(myCity) // { city: 'Las Vegas' }


//////////////////////////////  ИЗМЕНЕНИЕ ЗНАЧЕНИЙ СВОЙСТВА ОБЬЕКТА!  //////////////////////////////

// Переменная myCity ТИПА ОБЬЕКТ.
const myCity ={
    city: 'New York'
}
// В const находится ССЫЛКА на обьект myCity, поэтому мы можем менять его свойства и значения.
// Происходит мутация данного обьекта. Нужно делать копию обьекта и мутировать КОПИЮ обьекта а не ОРИГИНАЛ!

myCity.popular = true
// Добавили с помощью точечной записи в обьект свойство popular:  значение true.

console.log(myCity)
// { city: 'New York', popular: true}

myCity.country = 'USA'
// Добавили с помощью точечной записи в обьект свойство country:  значение 'USA'.

console.log(myCity)
// { city: 'New York', popular: true, country: 'USA' }



//////////////////////////////  УДАЛЕНИЕ СВОЙСТВ ОБЬЕКТА оператор delete!  //////////////////////////////

delete myCity.country
// Удалили свойство country

console.log(myCity)


//////////////////////////////  ДОСТУП К ЗНАЧЕНИЮ СВОЙСТВА С ИСПОЛЬЗОВАНИЕМ СКОБОК []  //////////////////////////////


const myCity ={
    city: 'New York'
}

myCity['popular'] = true
// Добавили в обьектс помощью [] свойство popular:  значение true.

console.log(myCity)
// { city: 'New York', popular: true }


const countryPropertyName = 'country'
// Поместили в переменную свойство 'country' для обьекта.

myCity[countryPropertyName] = 'USA'
// myCity[countryPropertyName] = 'USA' это мы так присвоили к свойству 'country' значение 'USA'
// Добавили country: 'USA' свойство хранится в переменной countryPropertyName.
// JS перед созданием свойства посмотрит в переменную countryPropertyName, после чего создаст свойство которое хранится в переменной countryPropertyName, далее присвоили значение свойства = 'USA'.
// Есди нужно создать свойство из перменной используем скобки [] в остальных случаях используем точечную запись.

console.log(myCity)
// { city: 'New York', popular: true, country: 'USA' }

// ОТЛИЧИЕ СКОБОЧНОЙ ЗАПИСИ ОТ ТОЧЕЧНОЙ, 
// В ТО ЧТО В CКОБОЧНОЙ ЗАПИСИ [] МОЖНО ИСПОЛЬЗОВАТЬ ЛЮБОЕ ВЫРАЖЕНИЕ!

// Пример 2

const myCity ={
    name: 'Vlad',
    age: 25
}

const myCountry = 'city'

console.log(myCity)
// { name: 'Vlad', age: 15 }


myCity[myCountry] = 'USA'

console.log(myCity)
// { name: 'Vlad', age: 15, city: 'USA' }


 //////////////////////////////  В JS МОГУТ БЫТЬ ВЛОЖЕННЫЕ СВОЙСТВА КОТОРЫЕ СОДЕРЖАТ ВЛОЖЕННЫЕ ОБЬЕКТЫ!  //////////////////////////////


 const myCity = {
    city: 'New York',
    info: {
        isPopular: true,
        country: 'USA'
    }
 }

 console.log(myCity.info.isPopular) // true 
// Точечная запись, переходим во вложенный обьект и выводим значение свойства isPopular.


delete myCity.info.isPopular
 // Получаем доступ в вложенный обьекта info и удаляем его с помощью оператора delete. 
 // Можно через скобочную [] запись delete myCity.info['isPopular']
 // Скобочную запись используем когда в скобках должно быть выражение, допустим название переменной.


 console.log(myCity)
 // { city: 'New York', info: { country: 'USA' } }


 //////////////////////////////  ИСПОЛЬЗОВАНИЕ ПЕРЕМЕННЫХ ПРИ ФОРМИРОВАНИИ ОБЪЕКТА! //////////////////////////////

//  const name = 'Vlad'
//  const postsQty = 23
//  // Используем название перменных как выражение для свойст обьекта.

//  const userProfile = { 
//     name: name,
//     postsQty: postsQty,
//     hasSignedAgreement: false
//  }

// Сначала JS получит результат того или иного свойства а после этого этот результат присвоится тому или иному свойству обьекта.

// Сокращенные свойства рекомендуется размещать в начале обьекта, чтобы было ясно где переменные в которых хранятся значения.

// const userProfile = { 
//     name,
//     postsQty,
//     hasSignedAgreement: false
//  }
 
// Сокращенный формат записи когда название переменной где находится значение свойства совподвет с название свойства!

// Обычно часть значений уже известно до формирования объекта, такие значения можно поместить в переменные. Допустим переменная password где будет находится пароль.


////////////////////////////// ГЛОБАЛЬНЫЕ ОБЪЕКТЫ! //////////////////////////////


console // Браузер глобальный обьект.

window.console // Hrome глобальный обьект.

global.console // Node.JS глобальный обьект.

globalThis // Унифицированный глобальный обьект.


// СВОЙСТВО ГЛОБАЛЬНЫХ ОБЬЕКТОВ 

window.console

global.console

console.log('Hello')

window.console.log('Hello')

global.console.log('Hello')
// Одно и тоже!



//////////////////////////////  МЕТОД - СВОЙСТВО ОБЪЕКТА ЗНАЧЕНИЕ КОТОРОГО - ФУНКЦИЯ! //////////////////////////////

// Методы - свойства обьекта, которые содержат функции.

const myCity = {
    city: 'New York',
    cityGreeting: function () {
        console.log('Greetings!!!')
    }
    
}
// В данном примере cityGreeting это метод. Вот city это просто свойство так как его значение не является функцией!!!
myCity.cityGreeting()
// Вызов МЕТОДА!

// Сокращенный формат записи без : и слова function!

const myCity = {
    city: 'New York',
    cityGreeting() { // Сокращенный формат записи.
        console.log('Greetings!!!')
    }
    
}


myCity.cityGreeting()
// Вызов МЕТОДА!


////////////////////////////// ЕСЛИ СРАВНИТЬ МЕТОДЫ VS СВОЙСТВА ОБЬЕКТОВ! //////////////////////////////

// Отличия СВЙОСТВА НЕ сожержат функции как значения а МЕТОДЫ СОДЕРЖАТ!!!
// шаблон обьекта свойство: значение

myCity.city
// Доступ к свойству

myCity.cityGreeting()
// Вызов метода



////////////////////////////// JSON! //////////////////////////////


// Есть 2 метода, для конвертиртации JSON в JS обьект и наоборот JS обьект в JSON.


JSON.parse()
// Конвертирует (парсим) JASON в JS Обьект.

JSON.stringify()
// Конвертирует JS Обьект в JASON.


const post = {
    title: 'My post',
    likesQty: 5
}
// Порядок свойств не имеет значения.

console.log(post)
// { title: 'My post', likesQty: 5 }

const postStringify = JSON.stringify(post)
// Конвертирует JS Обьект в СТРОКУ JASON.

console.log(postStringify)
// Получили СТРОКУ JSON '{"title":"My post","likesQty":5}'

const postParse = JSON.parse(postStringify)
// Конвертирует СТРОКУ JASON в JS Обьект.

console.log(postParse)
// Получили ОБЬЕКТ JS { title: 'My post', likesQty: 5 }

// JSON ЭТО ФОРМАТ ПЕРЕДАЧИ ДАННЫХ В ИНТЕРНЕТЕ!!!


////////////////////////////// МУТАЦИИ В JS! //////////////////////////////


// ЗНАЧЕНИЯ ПРИМИТИВНЫХ ТИПОВ!!! ЭТО ОЧЕНЬ ВАЖНО!!! ОСНОВЫ ОСНОВ!

// Крпирование по ЗНАЧЕНИЮ!
// ЗНАЧЕНИЕ ПРИМИТИВНЫХ ТИПОВ СОХРАНЯЕТСЯ НЕПОСРЕДСТВЕННО В САМИХ ПЕРЕМЕННЫХ!

const a = 10
// Переменная a ТИПА число ПРИМИТИВ!!!!

let b = a
// Обьявили новую переменную let b И КОПИРУЕМ a В b

b = 30
// 

console.log(a)
// 10

console.log(b)
// 30

////////////////////////////// ЗНАЧЕНИЯ ССЫЛОЧНОГО ТИПА!!! //////////////////////////////

const person = {
    name: 'Bob',
    age: 21
}

person.age = 22
// Изменили в свойстве age значение С 21 НА 22.
// Мутация Обьекта. Нужно делать копию ОБЪЕКТА и после его изменять.
person.isAdult = true
// Добавили свойство isAdult: и его значение true.
// Мутация Обьекта. Нужно делать копию ОБЪЕКТА и после его изменять.

console.log(person.age) // 22
console.log(person.isAdult) // true


// МУТИРОВАНИЕ ОБЬЕКТА ЧЕРЕЗ КОПИЮ.
const person = {
    name: 'Bob',
    age: 21
}


const person2 = person
// Крпируем ССЫЛКУ на обьект в памяти.
// То есть мы не обьект person скопировали в переменную person2 а ССЫЛКУ на один обьект в памяти!!!
// Теперь мы можем менять даннй обьект как через переменную person так и person2.


person2.age = 26
// Изменили в свойстве age значение НА 26.
person2.isAdult = true
// Добавили свойство isAdult: и его значение true.

// Мутируем обьект через ССЫЛКУ, которая хранится в переменной person2.
// То есть есть 1 обьект, ССЫЛКА на него находится в двух переменных person и person2.
// ЭТО ПРОИСХОДИТ И ЗА ТОГО ЧТО МЫ КОПИРУЕМ ТОЛЬКО ССЫЛКУ НА ОБЬЕКАТ А НЕ САМ ОБЬЕКТ!!!

console.log(person.age) // 26
console.log(person.isAdult) // true

// Всегда нужно помнить что ПРИМИТИВНЫЙ ТИП КОПИРУЕТСЯ ПО ЗНАЧЕНИЮ А ССЫЛОЧНЫЙ ТИП КОПИРУЕТСЯ ПО ССЫЛКЕ!!!





////////////////////////////// КАК ИЗБЕЖАТЬ МУТАЦИИ ОБЪЕКТОВ!!! //////////////////////////////

// Что делать если мы не хотим чтобы ОБЬЕКТ МЕНЯЛСЯ когда мы создаем КОПИЮ такого ОБЬЕКТА.

// Вариант номер 1

const person = {
    name: 'Bob',
    age: 25
}

const person2 = Object.assign({}, person)
// Object это и ТИП и КЛАСС потому с большой буквы O
// С помощью метода assign можем создать КОПИЮ нового обьекта на базе старого.
// То есть не ссылку на обьект а полностью новый обьект, МЕТОД assign создат новый обьект и запишет в него свойства обьекта person.
// Где в параметрах {} новый обьект С старого person.

person2.age = 26

console.log(person2.age) // 26
console.log(person.age) // 25

// Но если у обьекта person есть вложенные обьекты ТО ССЫЛКИ НА ЭТИ ВЛОЖЕННЫЕ ОБЬЕКТЫ СОХРАНЯЮТСЯ!!!
// То есть если есть свойство значение которого ОБЬЕКТ.

// Можно использовать Object.assign() где нет вложенных обьектов.



// Вариант номер 2


const person = {
    name: 'Bob',
    age: 25
}

const person2 = {...person}
// Три точки ... оператор СПРЕД (распыление)
// Берется обьект person и разделяется на свойства, в данном примере на name и age.
// Мы разделили старый обьект на свойства с помощью СПРЕД ... и сразу собрали эти свойства в НОВЫЙ обьект!
// person2 ЭТО НОВАЯ ССЫЛКА КОТОРАЯ ССЫЛАЕТСЯ НА НОВЫЙ ОБЬЕКТ!


person2.name = 'Alice'
// Меняем свойства НОГОВО обьекта person2.

console.log(person2.name) // Выводим свойство НОВОСОДАННОГО обьекта Alice
console.log(person.name) // Выводим свойство оригинального обьекта Bob


// Здесь как и в ВАРИАНТЕ 1 если у обьекта person есть вложенные обьекты ТО ССЫЛКИ НА ЭТИ ВЛОЖЕННЫЕ ОБЬЕКТЫ СОХРАНЯЮТСЯ!!!
// То есть меняя вложенные обьекты в распыленном обьекте спредом, ОНИ ПОМЕНЯЮТСЯ И В ОРИГИНАЛЬНОМ ОБЬЕКТЕ!!!
// Ссылки вложенных обьектов сохрянятся на ОРИГИНАЛЬНЫЙ обьект.

// Спред и Object.assign() МОЖНО ИСПОЛЬЗОВАТЬ ТОЛЬКО ЕСЛИ НЕТ ВЛОЖЕННЫХ ОБЬЕКТОВ!!!


////////////////////////////// ИЗБЕЖАТЬ МУТАЦИИ ОБЪЕКТОВ на 100% использую JSON!!! //////////////////////////////


// Вариант 3


const person = {
    name: 'Bob',
    age: 25
}

const person2 = JSON.parse(JSON.stringify(person))

// 1) Конвентируем обьект person в строку JSON.stringify(person) (Код работает как матрёшка, ИЗНУТРИ НАРУЖУ.)
// 2) На результате метода JSON.stringify(person) получили строку JSON.
// 3) Переадем строку JSON как аргемент в метод JSON.parse()
// 4) С помощью метода JSON.parse() мы обратно конвентируем строку JSON в ОБЬЕКТ JS.
// Итог, происходит двойная конвертация обьекта в строку JSON и обратно строка JSON в обьект!
// Мы получим новый обьект и в этом новом обьекте мы можем менять любые свойства, даже в вложенных обьектах.
// Оригинальный Обьект с которого мы делали конвертицию затронут не будет!
// Ссылки на вложенные обьекты если такие есть, НЕ СОХРАНЯЮТСЯ!!! Получили то что хотели.

person2.name = 'Alice'

console.log(person2.name) // Alice
console.log(person.name) // Bob



////////////////////////////// ФУНКЦИИ!!! //////////////////////////////


// 1. Функции - параметр это то что в скобках функции (локальная переменная внутри функции. Допустим a и b!
//     2. Аргумент в функции это значение для параметра во время вызова функции!
//     3. Если нужно что-то найти это значит перебрать массив, это цикл for или for of, forEach, map.
//     4. Если нужна что-то сравнить это if. 
//     5. Метод это функция объекта.
//     6. Ключевое слово This если есть вызов объект точка что-то это значит что слева , пример. user.xxxxx то This будет ссылаться на объект user! This ссылается время вызова! Не в момент объявления! Если This вызывает как метод объекта, This всегда ссылается на этот объект user.xxxxx! Если This вырывается без объекта foo(); тогда будет Undefined!
    

// Функция - это блок кода котрый можно выполнять многократно.

// Пример
let l = 5
let p = 3

c = l + p
// Одинаковые блоки кода!

console.log(c) // 8

let n = 10
let m = 5

c = n + m
// Одинаковые блоки кода!

console.log(c) // 8

// Очень рекомендуется избегать повторений блоков кода!

// На помощь приходят ФУНКЦИИ!

// Вариант 1
    function sum(a, b) {
    console.log( a + b ) 
    }


sum(10, 15) // 25

sum(10, 25) // 35

// Вариант 2
    function sumA(a, b) {
       const c = a + b 
       console.log(c) 
    }

a = 8
b = 12

    sumA(a, b) // 

    // Функция может быть...

    // 1) ...именованной
    // 2) ...присвоено переменной
    // 3) ...анонимной (без имени)
    // 4) ...аргументом при вызове другой функции (Callback функции)
    // 5) ...значением свойства (метода) обьекта. (Метод это свойство обьекта значение которого функция)

    // 3 ключевых ПОНЯТИЯ JS.
    // Выражения
    // Функции
    // Обьекты



////////////////////////////// ФУНКЦИЯ - ЭТО ОБЬЕКТ!!! //////////////////////////////


function myFn(a, b) { // (a, b) параметры функции, это переменные внутри функции а значение их определяются в момент ВЫЗОВА ФУНКЦИИ myFn(10, 5)!!!
let c
a = a + 1
c = a + b
return c // Вернет результат который равен переменной С
// После инструкция return Функция прекращает дальнейшие инструкции!!!
// Если после return есть каий-то операции они не будет выполнены!!!
// Если return ТО функция возвращает результат и заканчивает свою работу.
// Если использовали return ФУНКЦИЯ ВОЗВРАЩАЕТ РЕЗУЛЬТАТ И ЗАКАНЧИВАЕТ СВОЮ РАБОТУ!!!!
}

const res = myFn(15, 5) // Это (15, 5) аргументы!

console.log(res)

console.log(myFn.name) // myFn ФУНКЦИЯ - ЭТО ОБЬЕКТ.



////////////////////////////// ФУНКЦИЯ ВОЗВРАЩАЕТ UNDEFINED ЕСЛИ НЕТ ИНСТРУКЦИИ return ВАЖНО !!! //////////////////////////////


// Если мы говорим АРГУМЕНТЫ функции имеем ввиду ВЫЗОВ ФУНКЦИИ.
// // Если мы говорим ПАРАМЕТРЫ функции имеем ввиду ОБЬВЛЕНИЕ ФУНКЦИИ.

// Резюмируя 

// 1) Обьявили функцию в результате которой создасться переменная myFn.
// 2) Ее значение будет функция!
// 3) myFn(15, 5) вызыыввем функцию и в вызове указываем 2 аргумента 15 которые присвоятся в параметр a И 5 который присвоится в параметр b  function myFn(a, b)
// Функция возвращает значение!



function myFn(a, b) { 
    a = a + 1
    c = a + b
    return c 
    }    // ЕСЛИ НЕТ ИНСТРУКЦИИ return ФУНКЦИЯ ВОЗВРАЩАЕТ ЗНАЧЕНИЕ ТИПА UNDEFINED

    myFn(10, 3) // 14

// Что происходит внутри функции при ее вызове!

// 1) Параметрам "a" и "b" писваиваются значения 10 и 3
// 2) Обьявляется переменная "c"
// 3) Значение "a" увеличивается на 1
// 4) Сумма значений "a" и "b" присваивается "c"
// 5) Возвращает значение "c"

function myFn() {} // Самая короткая функция.

myFn() // undefined



////////////////////////////// ПЕРЕДАЧА ЗНАЧЕНИЯ ПО ССЫЛКЕ !!! //////////////////////////////

const personOne1 = {
    name: 'Bob',
    age: 21
}

function increasePersonAge(person) {
    person.age +=1
    return person
}
// Внутри ФУНКЦИИ мутация ВНЕШНЕГО обьекта. Так делать НЕ РЕКОМЕНДУЕТСЯ!!!
// В параметр функции person передаем как аргумент обьект personOne.
// После переходим в person.age где значение 21 с помощью +=1 добавлем 1 получаем 22.

increasePersonAge(personOne1)
// Вызов функции increasePersonAge с передачей как аргумент обьект  personOne.
console.log(personOne1.age)

// Мы по ссылке которая находится в переменной в ОРИГИНАЛЬНОМ ОБЬЕКТЕ поменяли значение age: 21 на age: 22.



////////////////////////////// ВНУТРИ ФУНКЦИИ НЕ РЕКОМЕНДУЕТСЯ МУТИРОВАТЬ ВНЕШНИЕ ОБЪЕКТЫ!!! //////////////////////////////


// То есть мы не передаем ОРИНИНАЛЬНЫЙ ОБЬЕКТ как аргумент в ФУНКЦИЮ.
// Мы можем создать копию обьекта внутри функии!




const personOne = {
    name: 'Bob',
    age: 21
}

function increasePersonAge(person) {
    const updatePerson = Object.assign({}, person) // Создали НОВЫЙ ОБЬЕКТ и присвоили в переменную updatePers ОБЬЕКТ на БАЗЕ СТАРОГО personOne.
    updatePerson.age += 1 // К новому обьекту pdatePerson в свойство age добавили значение 1 на выходе получили age: 22
    return updatePerson // Возвращаем новый ОБЬЕКТ updatePerson.
}

const updatePersonOne = increasePersonAge(personOne) // Вызов ФУНКЦИИ 
console.log(personOne.age) // 21
console.log(updatePersonOne.age) // 22

// Вывод мы передаем ОБЪЕКТ в ФУНКЦИЮ не изменяя оригинальный ОБЪЕКТ.
// Чтобы не было мутации оригинального обьекта!!! Это важно!
// На выходе personOne НЕ ИЗМЕНИТСЯ, мы будем менять КОПИЮ такого ОБЬЕКТА.

// ФУНКЦИИ НЕ ДОЛЖНЫ МЕНЯТЬ ВНЕШНИЕ ПЕРЕМЕННЫЕ ОНИ ДОЛЖНЫ РАБОТАТЬ С СВОИМИ ВНУТРЕННИМИ ПЕРЕМЕННЫМИ!!!



//////////////////////////////  КОЛБЕК ФУНКЦИИ ВАЖНО!!!  //////////////////////////////



// Колбэки и функции высшего порядка. Фундаментальный JavaScript
// Ссылка на ролик https://youtu.be/ab0a8ZbCNMY

    // 3 ключевых ПОНЯТИЯ JS.
    // Выражения const c = a + b
    // Функции function myFn(a, b) {}
    // Обьекты {}

    //Пример

    // Функция 1
    function anotherFunction() {
        // Действия... 
        // Функция которую мы положим как аргумент в параметр Функции fnWithCallback.
        // Она же КОЛБЕК ФУНКЦИЯ!!!
        // Данная КОЛБЕК ФУНКЦИЯ передается как аргумент в другую функцию.
    }

        // Функция 2
    function fnWithCallback(callbackFunction) {
callbackFunction()
// Вызывает ТУ ФУНКЦИЮ которую положат в ПАРАМЕТР.
// В теле этой функции вызывается КОЛБЕК ФУНКЦИЯ, Функция 1.
    }

        // Вызов ФУНКЦИИ 2 И в ПАРАМЕНТР КЛАДЕМ ФУНКЦИЮ 1 !!!
    fnWithCallback(anotherFunction)
    // Вызов функции 

  // Пример

  function printMyName() {
    console.log('Vlad')
  }

  console.log('Start')

  setTimeout(printMyName, 2000) // Функция setTimeout отложенного запуска.
  // Эта функция отложенного запуска, вызывает внутри себя функцию которая передана как первый аргумент в вызове Функции setTimeout.
  // В данном примере, одна функция вызывает другую через отложенное время а именно 2 секунды.


// Колбэки и функции высшего порядка. Фундаментальный JavaScript


// Вариант номер 1

function treeSquared() {
    return 3 * 3
}
// Вернет 9

// Вариант номер 2

function numSquared(num) {
    return num * num
}

numSquared(3)
// Вернет нечто умноженное само на себя!
// Вернет 9

// Аналогичный пример но уже с МАССИВАМИ где учавствует ПЕРЕБОР for!!!

// Пример 1 умножение.

function copyArrayAndSquareNums(arr) { // В параметр arr получим МАССИВ!
    const output = []; // Создаем новый массив.

    for (let i = 0; i < arr.length; i += 1) {
     output.push(arr[i] ** 2); // Новый синтаксис ** 2 или arr[i] * arr[i]
        
    }
    // Обходим ориг массив умножаем само на себя число и в изменненый массив бросаем в новый массив output.

    return output;
    // Вернем новый output массив.
}


// Пример 2 деление.


function copyArrayAndSquareNums(arr) { 
    const output = [];

    for (let i = 0; i < arr.length; i += 1) {
     output.push(arr[i] / arr[i]);
        
    }

    return output;
    
}
// По факту в примере 1 и 2 аналогичный код за исключением отлиыия в одной строке output.push(arr[i] / arr[i])

// И тогда мы приходим к КОЛБЕК ФУНКЦИЯМ!!!


//Функции Callback!

//Функции высшего порядка это функции которые принимают в аргумент другую функции!

//Callback функции это отдельная функция которая передается в функцию высшего порядка как аргумент! (То есть как ссылка на данную функцию, функция вашего порядке будет на нее ссылаться.)

//Замыкание Функции!

//Функция вашего порядка может создать функцию внутри себя, и возвращает их через оператора return. Это уже замыкание.

const arrM = [1, 2, 3, 4, 5]

function copyArrayAndDoSmth(arr, instructions) { 
    const output = [];

    for (let i = 0; i < arr.length; i += 1) {
     output.push(instructions(arr[i]));
        
    }

    return output;
    
}

function numSquared(num) {
    return num * num
}
// КОЛБЕК ФУНКЦИЯ!

function divideBy2(num) {
    return num / num
}
// КОЛБЕК ФУНКЦИЯ!


const resFn = copyArrayAndDoSmth(arrM, numSquared)
// Вызов ФУНКЦИИ ВЫСШЕГО ПОРЯДКА с передачей МАССИВА как первый аргмент и передачей КОБЕК ФУНКЦИИ КАК ВТОРОЙ АРГУМЕНТ!

console.log(resFn)
// [ 1, 4, 9, 16, 25 ]




  //////////////////////////////  ПРАВИЛА РАБОТЫ ФУНКЦИИ !!!  //////////////////////////////

// 1) Называть функции исходя из выполняемых задач.
// Чтобы было понятно что функция делает, как и название любых переменных.

// 2) Одна функция дожна выполнять одну задачу.
// Функция которая работает с числами И отдельно функция которая работает с строками.

// 3) Не рекомендуется изменять внешние относительно функции перменные.
// Если функция работает с обьектами, то внутри функции содаем копию таких обьектов и меняем их,
// не меняя при этом оригинальные обьекты которые были переданы как значение аргументов.
// То есть функция должна быть чистой, функция работает только с перменными которые обьявлены внутри самой функции И ОНА НЕ МЕНЯЕТ ВНЕШНИЕ ПЕРЕМЕННЫЕ!!!
// ДАЖЕ ТЕ КОТОРЫЕ ПЕРЕДАНЫ КАК АРГУМЕНТ ЭТОЙ ФУНКЦИИ.

// Если в функции нету return то функция возвращает undefined.


//////////////////////////////  ЗАМЫКАНЕИ ФУНКЦИИ !!!  //////////////////////////////

// Замыкание в JavaScript

// 1. Функция в качесиве своей работы возвоащает новые функции.
// По сути функция генерирует новую функцию внутри себя и возвращает наружу.

// 2) Возвращаемые функции помнят контекст, где были созданы.





 //////////////////////////////  ОБДАСТЬ ВИДИМОСТИ !!!  //////////////////////////////

 // Область видимости определяет границы действия переменной.

 // 1) ЕСТЬ ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ которые обьявлены в ГЛОБАЛЬНОЙ ОБЛАСТИ ВИДИМОСТИ.
 // 2) ЕСТЬ ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ которые обьявлены в ЛОКАЛЬНОЙ ОБЛАСТИ ВИДИМОСТИ.

// Пример 1

 let z // Создали глобальные переменные на одному ряду с глобальным обьектом window!
 let x // Создали глобальные переменные на одному ряду с глобальным обьектом window!

 function myFn() { // Глобальная область видимлсти видит myFn.
    let x // Обявлена локальная переменная! Доступна только {внутри скобок функции}
    z = true
    x = 10
    console.log(x) // 10
 }

 // При вызове функции в теле функции, между скобками создвется {локальная область видимлсти}


 myFn()

 console.log(z) // true
 // Внутри  функции присвоили  z = true, так как внутри функции нету перменной z, присвоили выше по коду к глобальной перменной z.
 console.log(x) // undefine
// Вывод рузультата обращения к глобальной переменной X

// Итог 

// 10
// true
// undefined

// Пример 2

const o = 5

function myFn() {
    function innerFn() {
        console.log(o) // 5
    }
    innerFn()
}

myFn()

// console.log(o) // 5
// Резутьтат вызова функции myFn() undefined
// Функция не имеет ключевого слова return поэтому возврат вызова myFn() будет undefined.

// 1) Создали в глобальной области видимости переменную o.
// 2) Создали в глобальной области видимости функцию myFn.
// 3) При вызове функции myFn создается внутри нее функция innerFn().
// 4) Вызываем в облвсти видимости функии myFn функцию innerFn().
// 5) В локальной области видимости innerFn() создается  console.log(o).
// 6) При вызове функции innerFn() интерпретатор js пойдет искать переменную o по коду выше.
// 7) Ищет в локальной области видимости функции innerFn(), здесь нету.
// 8) Ищет в локальной области видимости функции myFn(), и здесь нету.
// 9) Идет в глобальную облась видимости и там находит переменную const o = 5.
// 10) Выводит в консоль значение меременной const o = 5.

// ЭТО НАЗЫВАЕТСЯ ЦЕПОЧКА ОБЛАСТЕЙ ВИДИМОСТИ!





 //////////////////////////////  ЖИЗНЕННЫЙ ЦИКЛ ПЕРЕМЕННЫХ !!!  //////////////////////////////



//  let a
//  let b
 
//  function myFn() {
//  let b
//  a = true
//  b = 10
//  console. log(b) // 10
 
//  myFn()
 
//  console. log(a) // true
//  console. log(b) // undefined

// ЖИЗНЕННЫЙ ЦИКЛ ПЕРЕМЕННОЙ b

// 1) let b обьявление переменной "b" в глобальной обоасти видимости. Ее значение undefine, так как изначально мы не присваиваем значение.
// 2) Вызов функции myFn() после чего содается локальная зона видимости в функции myFn().
// 3) let b Обьевление "b" в локальной зоне видимости функции myFn().
// 4) b = 10 Интерпретатор js ищет в рамках функции, находит let b в области видимости функции и присваивает ей значение 10.
// 5) console. log(b) // 10 Внутри функции вывод в консоль b.
// 6) Функция myFn() заканчивает свою работу. Переменная b в глобальной зоне видимости все так же undefined.
// 7) В глобальной зоне видимости выводим console. log(b) получаем undefined.
// После того как отработала функция myFn() ее переменные были удалены!!!


// ЖИЗНЕННЫЙ ЦИКЛ ПЕРЕМЕННОЙ a

// 1) let a обьявление переменной "a" в глобальной обоасти видимости. Ее значение undefine, так как изначально мы не присваиваем значение.
// 2) Вызов функции myFn() после чего содается локальная зона видимости в функции myFn().
// 3) Обьвлена ли "a" в зоне видимости функции? НЕТ и нет параметра с таким именем. Обьвлена ли "a" в внешней области видимости? ДА. Присваиваем значение a = true.
// Итог изнутри ЧТО НЕ РЕКОМЕНДУЕТСЯ функции присвоили значение true вглобальную переменную a. До присвеяния у переменной a было значение undefined.
// Функция myFn() заканчивает свою работу. Все локальные переменные функции myFn() удалились.
// 4) В глобальной зоне видимости выводим console. log(a) // true

// НЕ РЕКОМЕНДУЕТСЯ ИЗНУТРИ ФУНКЦИИ МЕНЯТЬ ЗНАЧЕНИЕ ВНЕШНИХ ПЕРЕМЕННЫХ!!!
// Чтобы избежать этого, нам нужно обьявлять новые переменные внутри функции, как сделанно с переменной b.
// В этом вся разница глобальной зоной видимости и локальной!

// ПЕРЕМЕННАЯ В ЛОКАЛЬНЫЙ ЗОНЕ ВИДИМОСТИ ВСЕГДА ИМЕЕТ ПРИОРИТЕТ!!!
// То есть интерпретатор JS начнет посик переменной именно с локальной зоны видимости ПОСЛЕ ЧЕГО ПОЙДЕТ ВВЕРХ ПО КОДУ!





 //////////////////////////////  ТИПЫ ОБЛАСТЕЙ ВИДИМОСТИ !!!  //////////////////////////////

 // 1) Глобальная облась видимости.
 // 2) Область видимости функции.
 // 3) Облась видимости БЛОКА.

 // Переменные, обьявленные с помощью let и const внутри блока имеют область видимости, ограниченную этим блоком.

 // Блок это все что находится {между скобками}

 if (5 > 2) {
    console.log('Hello') // То есть console.log('Hello') находится внутри блока!
 }

 // Пример как делать НЕ НУЖНО!!!

 function myFn() {
    a = true // Ищем переменную a в локальной зоне видимости или выше по коду, не находим. После чего создается атоматически переменна a.
    // Причем такая переменная "a" будет создана в ГЛОБАЛЬНОЙ области видимости!!!
    console.log(a) // true
 }

 myFn()

 console.log(a) // true
 // Обращение в ГЛОБАЛЬНОЙ области видимости к переменной "a".
 // true это то значение которое было присвоено внутри функции переменной "a" псле чего атоматически было создано В ГЛОБАЛЬНОЙ ОБЛАСТИ ВИДИМОСТИ.
// Когда в итоге мы не нашли не где такой переменной!

// ТАК ДЕЛАТЬ КРАЙНЕ НЕ РЕКОМЕНДУЕТСЯ!!!!!!!

// НЕ РЕКОМЕНДУЕТСЯ приставивать внутри ФУНКЦИИ какй-то значение переменным которые ранее не были обьявлены.


 //////////////////////////////  ПРАВИЛА РАБОТЫ С ПЕРЕМЕННЫМИ !!!  //////////////////////////////

 // 1) Все переменные обьявлять перед их использованием! (Чтобы автоматически не содавались переменные)
 // 2) Старасться использовать const везде где это вохможно!
 // 3) Внутри функции не изменять переменные с внешних областей видимости.

// Чтобы соблюдать данные правила, нужно внутри функции объявлять те переменные которые нам нужны в рамках функции.

// Параметры функции это своего рода переменные, которые получают значениие в момент вызова функции!

// СТРОГИЙ РЕЖИМ !!!

 //////////////////////////////  СТРОГИЙ РЕЖИМ !!!  //////////////////////////////

 'use strict' // Это инструкция JS более пристально наблюдать за переменными и не только.
 // Достаточно добавить первой строкой в любой код, допустим еад функцией которая что-то делает.

 function myFn() {
    a = true 
    console.log(a)
 }

 myFn()

 console.log(a)

 // В данном примере интерпретатор JS ищет переменную вверх по коду, он ее не найдет, и вместо того чтобы создать переменную "a" автоматически ОН ВЫДАСТ ОШИБКУ!


  //////////////////////////////  ОПЕРАТОРЫ !!!  //////////////////////////////

// Арифметические
//   + плюс      - минус       * умножить      / разделить


// Сравнения
// === равно      !== неравно       меньше либо равно <=      больше либо равно >=


// Логичесике операторы
// ! "НЕ"       && "И"      || "ИЛИ"


// Оператор Присваивания равно  =


// ТЕКТОВЫЕ ОПЕРАТОРЫ

// typeof - можно проерсить того или иного значения.
// instanceof - можно проверить принадлежность обьекта тому или иному кдассу.
// new - Обычный синтаксис {...} позволяет создать только один объект. Но зачастую нам нужно создать множество похожих, однотипных объектов.
// delete - можно удвлить свойство в обьекте.


// Есть еще оператор запятая ","

let test, test1 // Создаст 2 переменные в глоабальной области видимости.

test = 10
// Присваивание "=" 10
test1 = test
// Присваивание "=" test1 = test

let u = test1 + test
// Присваивание "=" выражение test + test1. И есть оператор плюс "+"
// Сначала мы получим результат test1 + test выражения и после произайдет присваивание выражения в переменную "с".

console.log(u) // 20


//////////////////////////////  ОПЕРАТОР ПРИСВАИВАНИЯ !!!  //////////////////////////////

// ОПЕРАТОР - ВСТРОЕННАЯ ФУНКЦИЯ.

// a = 10
// "a" и 10 это операнды, левый операнд и правый операнд. 

// function =(переменная, выражение) {
//     1. Получение результата выражения
//     2. Поиск переменной по имени
//     3. Присваивание результата выражения переменной
//     4. Возврат результата выражения
// }

// Это то что подкапотом у так называемой функции равно.


//////////////////////////////  УНАРНЫЕ ОПЕРАТОР !!!  //////////////////////////////


// У УНАРНЫХ ОПЕРАТОРАХ ВСЕНДА ОДИН ОПЕРАНТ ИЛИ АРГЕМЕНТ.

// "a++" такой оператор увеличивает значение переменной на еденицу 1.
// "a+" можно конвентировать строку в число.
//  "delete" obj.a пусть к свойству одного обьекта.
// "typeof" a провреить на ТИП той или иной переменной.
// "new" Jbject() c помощью него можно создать екземпляр класса того или иного обьекта.


//////////////////////////////  БИНАРНЫЕ ОПЕРАТОР !!!  //////////////////////////////

// У БИНАРНЫХ ОПЕРАТОРОВ ВСЕГДА ДВА ОПЕРАТОРА ИЛИ АРГЕМЕНТА!

// Оператор присваивания и два опернда. 

// Левый операнд это название переменной и правый операнд это выражение.

// a = 5 

// a + b

// a += 5 
/// берем значение "a" увеличиваем на 5 и присваиваем результирующее значение переменной "a"

// a === b
// Сравниваем значение двух переменных "a" и "b" ("===" сравнивает как тип так и значение.)
// Если мы попробуем сравнить число 5 и строку пять. То результат будет false, так как строка 5 не ровна цифре 5.
// Если сравним мтроку 5 и строку 5 то будет true так как эти строки одинаковы.

// a && b




//////////////////////////////  ФОРМАТЫ ЗАПИСИ ОПЕРАТОРОВ !!!  //////////////////////////////

// ИНФЕКСНАЯ ЗАПИСЬ

// Оператор находится между ОПЕРАНДАМИ. Это инфексная запись.
// a = true

// a + b

// a += 5

// a || b (Оператор или)

// a > b


// ПРЕФИЕСНАЯ ЗАПИСЬ это окогда сначала пишем оператор и после переменную.
// Операнд идет за оператором.

// "++a" это префиксная запись оператора ++ (Можно и a++)

// "delete" Object.a

// "typeof" a


// ПОСТФИКСНАЯ ЗАПИСЬ это окогда сначала пишем переменную и после оператор.

// a++

// a--

// myFunction() скобки () это оператор который говрит JS вызвать определенную функцию.
// Имя функции это операнд а скобки оператор вызова функции.

// Оператор идет за операндом.


//////////////////////////////  ПРИОРИТЕТНОСТЬ ОПЕРАТОРОВ !!!  //////////////////////////////

// const a = 30

// const b = 70

// const c = 80

// const d = 40

// const e = 50

// const result = a + b * c / d - e

// 1) Умножение b * c (70 * 80 = 5600)
// 2) Результат выражения b * c мы делим / на "d" (5600 / 40 = 140)
// 3) Сложим результат с значение переменной "a" (140 + 30 = 170)
// 4) После чего отнимем значение переменной "e" (170 - 50 = 120)
// Ответ 120

//////////////////////////////////////////////////////////////////////

// Если мы хотим поменять стандартную математическую приоритетность. 
// Мы можем сгрупировать в скобки.


// const a = 30

// const b = 70

// const c = 80

// const d = 80

// const e = 50



// a + ((a * c) / (d - e))

// 30 * 80 = 2400

// 80 - 50 = 30

// 2400 / 30 = 80

// 80 + 30 = 110

// 1) Умножение "a" * "c" (30 * 80 = 2400)
// 2) "d" - "e" (80 - 50 = 30)
// 3) Рузультат (a * c) делим на результат (d - e) пример - (2400 / 30 = 80)
// 4) После чего к резутату выражения плюсуем "a" (80 + 30 = 110)
// Ответ 110

///////////////////////////////////////////////////////////////////////////////

// const a = 30

// const b = 70

// const c = 80

// const d = 80

// const e = 50

// (((a + b) * c / d) - e)

// Ответ 50


// 1) Умножение "a" + "b" (30 + 70 = 100)
// 2) рузультат выражения (a + b) * c)  * "d" (100 * 80 = 8000)
// 3) Рузультат  (8000 / 80 = 100)
// 4) Результат ((a + b) * c / d) выражения минусуем "e" (100 - 50 = 50)
// Ответ 50



//////////////////////////////  ЛОГИЧЕСКИЕ ОПЕРАТОРЫ !!!  //////////////////////////////


// ОПЕРАТОР "!" НЕ префиксный оператор, пишется перед операндом!

// Пример !name или !a
// Не имя, не переменная "a"

// И "&&" еще ОПЕРАТОР ИЛИ "||" ЭТО БИНАРНЫЕ ОПЕРАТОРЫ У НИХ 2 ОПЕРАНДА!!!
// Можно обьеденять эти 2 оператора И "&&" ИЛИ "||"

// ОПЕРАТОР И "&&""


// ОПЕРАТОР ИЛИ "||"


// ОЧЕНЬ ВАЖНО ПОНИМАТЬ ЧТО ОПЕРАТОР НЕ "!" всегда возвращает значение ТИПА boolean, НЕ ЗАВИСИМА ОТ ЗНАЧЕНИЯ ОПЕРАНДА!


// То есть оператор "!" всегда возвращает либо true либо false!!!!!!!!!!!!!

// Операторы И && и ИЛИ || ВОЗВРАЩАЕТ ЗНАЧЕНИЕ ОДНОГО ИЗ ОПЕРАНДОВ!!!!!!!!!
// Какого операнда, зависит от значений других операндов. Будут примеры.


//////////////////////////////  ЛОЖНЫЕ ЗНАЧЕНИЯ В JS  //////////////////////////////

// Ложными значениями считаются те значения, которые при привидении к логическому типу Boolean дают false.

// Привести любое значение к типу Boolean можно путем вызова функции Boolean(0) -> false.
// Boolean(value) -> false

// Это перечень значений которые приводят к false, все же остальные значения приведут к true!!!
// false (не истина)
// 0 (ноль)
// '' (пустая строка)
// undefined (неопределенно)
// null (ноль)


//////////////////////////////  ПРАКТИКА с typeof ОПЕРАТОРОМ  //////////////////////////////

// typeof это унарный оператор и это префиксный оператор.

// typeof 10
// Ответ 'number'

// typeof "Vlad"
// 'string'

// typeof false
// 'boolean'

// Это то как можно легко определить того или иного значения!


// Пример

// typeof 10 === 'number'
// typeof в данном примере сравнивает 'number' === 'number'

// let isUndefined

// typeof isUndefined === 'undefined'
// true


//////////////////////////////  ОПЕРАТОР "!" ЧАЩЕ ВСЕГО ИСПОЛЬЗУЕТСЯ в УСЛОВНЫХ ИНСТРУКЦИЯХ  //////////////////////////////

// Это такие инфтрукции как if, if else и тд...

// Примеры с оператором НЕ "!"

!10   // false
!0   // true
!'abc'     // false
!''   // true
!true   // false
!undefined   // true

// Как инверсия!!!
!false // true

// Двойное ОТРИЦАНИЕ !!

!!10   // true
!!0 (Ложное)   // false
!!'abc'     // true
!!'' (Ложное)  // false
!!true   // true
!!undefined (Ложное)  // false

const oB = {}

!!oB // true

// С помощью оператора НЕ НЕ !! или НЕ ! любое значение можно привести в буливому!

// Ложные значения с двойным отрицанием всегда даст false на выходе.

// Если исходное значение правдиво или истино, то двойное отрицание даст нам вседа true.



//////////////////////////////  ОПЕРАТОРЫ "&&" и "||" ЯВЛЯЮТСЯ ОПЕРАТОРАМИ КОРОТКОГО ЗАМЫКАНИЯ!  //////////////////////////////

// Булевое true или false работает так.
// Логические И запинается на лжи/false и возвращает то на чем запнулось или последний опертанд.
// Логическое ИЛИ запинается на правде/true и возвращает то на чем запнулось или последний опертанд.
// Логическое НЕ !==
// Приводит опертанд к булю, если необходимо, а затем делает инверсию tru это будет false и наоборот.


// Логическое И запинается на лжи и возвращает то на чем запнулось или последний операнд. Работает до первого false, как только его встречает, он его возвращает.

// (Должно все быть true)

// Логическое ИЛИ запинается на правде И возвращает то на чем запнулось или последний опертанд. Оператор или срабатывает на первом true и его возвращает.

// (Должен быть хоть один true)

const password = 555
let enterinPassword = 898
let massage = null

if (password === enterinPassword) {
    massage = 'Пароль верный'  // Если true 
    console.log(massage)
} else {
    massage = 'Пароль НЕ верный!' // Если false
    console.log(massage)
}



// Оператор И "&&" запинается на лжи/false и возвращает то на чем запнулось или последний опертанд.

// Выражение 1 && Выражение 2
// В примере два операнда, между ними И "&&"

// Если "выражение 1" ложно:

// 1. Выражение 2 игнорируется!!!!!!
// 2. Возвращается результат "Выражения 1" как всего выражения "Выражение 1 && Выражение 2"

// Каждый из операндов это выражение. Любое выражение возвращает значение!!!

// Оператор И "&&" ТРЕБУЕТ В РЕЗУЛЬТАТЕ ВСЕ ЗНАЧЕНИЯ true
// Чтобы результирующее значение было правдиво!


// 1) Если "Выражение 1" истено мы оцениваем "Выражение 2"
// 2) Если "Выражение 2" ложно, возвращается результат этого выражения!!!

// Пример.

// Допустим для выезда за границу нужны паспорт И страховка. Если чего-то нету будет false если все есть будет true.


// Если два Выражение 1 && Выражение 2 ИСТИНО, вернет последний опернад то есть "Выражение 2"


///////////// Оператор И "||"
// В примере два операнда, между ними ИЛИ "||"

// Выражение 1 || Выражение 2

// Если "выражение 1" истино:

// 1. Выражение 2 игнорируется!!!!!!
// 2. Возвращается результат "Выражения 1" как всего выражения "Выражение 1 && Выражение 2"

// Возможно для поездки в страну достаточно ЛИБО заграничного паспорта ЛИБО национального.
// Это как раз ИЛИ ЛИБО то ЛИБО то true.

// Если "Выражение 1" истино все это выражение вернет РЕЗУЛЬТАТ "ВЫРАЖЕНИЯ 1"!!!!!!!!



// ТРЮК С ОПЕРАТОРАМИ И "&&" и ВЫЗОВОМ ФУНКЦИИ!!!


let q = 10

q && console.log('Выполнено!')
// Как результат всего выражения мы получим undefined, так как метод log возвращает undefined.
// Кроме того мы увидим Выполнено!, так как это то что выполняется в нутри метода log.

// Переменная q это значение 10 то есть true, проверяем второе значение оно true выполняем console.log('Выполнено!').
// ТО ЕСТЬ С ПОМОЩЬЮ ЭТОЙ ПРОВЕРКИ ПО true МОЖНО ЗАПУТИТЬ ФУНКЦИЮ!!!


let i = 0

i && console.log('Выполнено!')
// Запнется на лжи и вернет 0, второе заначение даже не будет рассматриваться.

// MDN Логическое И (&&)
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Logical_AND

// Описание
// Логическое И (&&) вычисляет операнды слева направо, возвращая сразу значение первого попавшего ложноподобного операнда; 
// если все значения истиноподобны, возвращается значение последнего операнда.

// Примеры выражений, которые могут быть преобразованы в false:

// false;
// null;
// NaN;
// 0;
// пустая строка ("", '', ``);
// undefined.


// result = '' && 'foo';  // result is assigned "" (empty string)
// result = 2 && 0;       // result is assigned 0
// result = 'foo' && 4;   // result is assigned 4


// Несмотря на то, что оператор && может использоваться с операндами, не содержащие логических значений, он всё равно останется булевым оператором, 
// поскольку его возвращаемое значение всегда можно преобразовать в булевый примитив. Чтобы явно преобразовать возвращаемое значение этого оператора 
// (или вообще любое выражение) в соответствующее значение булевого типа, используйте двойной оператор НЕ или конструктор Boolean (en-US).


// Поскольку первый операнд (ложноподобное выражение) имеет ложное значение, то следующее выражение никогда не будет вычислено. 
// Если следующее выражение содержало функцию, то она бы никогда не была вызвана. Посмотрите пример ниже:

function A() { console.log('вызвана функция A'); return false; }
function B() { console.log('вызвана функция B'); return true; }

console.log( A() && B() );
// В результате вызова функции A, в консоли будет выведено "вызвана функция A",
// а оператор && вычислится как false (функция A возвращает false), поэтому далее в консоли появится false;
// вследствие этого оператор И прекратит вычисление и проигнорирует функцию B

// Приоритет операторов
// Оператор И имеет более высокий приоритет, чем оператор ИЛИ, поэтому оператор && выполнится раньше оператора || (см. приоритет операторов).

false || true && true            // вернёт true
true && (false || false)         // вернёт false
(2 == 3) || (4 < 0) && (1 == 1)  // вернёт false


// const myFn = () => {console.log('Стрелочная функция Выполнено!')} 


// console.log(5 && myFn)



////////////////////////////// ЦЕПОЧКА ОПЕРАТОРОВ && И ||   //////////////////////////////



 // Ищем первое ЛОЖНОЕ ЗНАЧЕНИЕ.
a && b && c && d
// Если любая из переменных ложна, вернется та переменная на которой будет false, если все переменные истина, вернется последняя переменная "d" даже если "d" ложно!!!
// За паременной может быть целове выражение, функция.


 // Ищем первое ПРАВДИВОЕ ЗНАЧЕНИЕ.
a || b || c || d
// Если "a" правдиво, возвращаем "a" на остальные не смотрим.
// Есди a, b, с, ПРАВДИВО возвращаем "d" даже если оно ЛОЖНО!!!


// ВАЖНО! Операторы И "&&" и ИЛИ "||" всегда возвращают ЗНАЧЕНИЕ ОДНОГО ИЗ ОПЕРАНДОВ!!!

// Всего три логических оператора, НЕ "!"   И "&&"   ИЛИ "||"



////////////////////////////// ОПЕРАТОР РАЗДЕЛЕНИЯ ОБЬЕКТОВ НА СВОЙСТВА "..."   //////////////////////////////

// Пример 1

const buttonT = {
    width: 200,
    text: 'Buy'
}

const redButton = {
    ...buttonT,
    color: 'red'
}
// В данном примере, мы создадим обьект redButton после чего добавим свойства  width: 200, text: 'Buy' обьекта button.
console.table(redButton) // Табличка
console.log(redButton) // { width: 200, text: 'Buy', color: 'red' }


// Пример 2


// const bluButton = {
//     width: 200,
//     text: 'Buy',
//     color: 'blu'
// }

// const greenButton = {
//     color: 'green',
//     ...bluButton 
// }
// Разберет обьект на свойста и перезапишет существующее свойство color: 'green' на color: 'blu'.
// ПОРЯДОК СВОЙСТВ ВАЖЕН, если будут одинаковые свойства, они могут друг друга перезаписать!!!

// console.log(greenButton) // { color: 'blu', width: 200, text: 'Buy' }




const bluButton = {
    width: 200,
    text: 'Buy',
    color: 'blu'
}

const greenButton = {
    ...bluButton, 
    color: 'green'  
}
// Разберет обьект на свойста и перезапишет существующее НОВОЕ color: 'blu' на color: 'green'.
// ПОРЯДОК СВОЙСТВ ВАЖЕН, если будут одинаковые свойства, они могут друг друга перезаписать!!!

console.log(greenButton) // { width: 200, text: 'Buy', color: 'green' }



//////////////////////////////   ОБЬЕДИНЕНИЕ ОБЬЕКТОВ С ПОМОЩЬЮ "..."   //////////////////////////////


const buttonInfo = {
    text: 'Buy'
}

const buttonStyle = {
    color: 'yellow',
    width: 200,
    height: 300
}

const button = {
...buttonInfo,
...buttonStyle
}
// Обьеденили два обьета buttonInfo и buttonStyle в button с помощью "..."
// ПОРЯДОК СВОЙСТВ ВАЖЕН, если будут одинаковые свойства, они могут друг друга перезаписать!!!

console.log(button)
// { text: 'Buy', color: 'yellow', width: 200, height: 300 }


// Помним что обьекты ссолочный тип, оператор ... разделяет ориг обьекты на свойства и создает новый обьекты на базе оригинальных.
// Важно, если у ориг обьектов будут вложенные обьекты, ссылки на них сохранятся!
// С помощью оператора "..." можно легко создавать новые обьекты на основании других оьектов.



//////////////////////////////   КОНКАТЕНАЦИЯ СТРОК!   //////////////////////////////


// 'Hello ' + 'World'
// // Внемание на пробел после слова Hello.
// // 'Hello World'

// // ПЕРЕМЕННЫЕ В КОНКАТЕНАЦИИ СТРОК

// const hello = 'Hello'
// const world = 'World'

// const greeting = hello + ' ' + world

// console.log(greeting )
// Hello World

// Это все стрый вариант КОНКАТЕНАЦИИ! На помошь приходят ШАБЛОННЫЕ СТРОКИ.



//////////////////////////////   ШАБЛОННЫЕ СТРОКИ!   //////////////////////////////

const hello = 'Hello'
const world = 'World'

const greeting = `${hello} ${world}`

console.log(greeting)
// Hello World

const myName = 'Vlad'
const myCity = 'Kiev'


const templateString = `Меня зовут ${myName} я живу в городе ${myCity}`

console.log(templateString)


10 + 'Vlad' // '10Vlad'
// Произошла конвертация числа в строку, после чего соединила '10Vlad' как строку.
// Число привелось в тип строка, после чего получилась строка'10Vlad'



//////////////////////////////   ФУНКЦИОНАЛЬНЫЕ ВЫРАЖЕНИЯ!   //////////////////////////////


// ОБЬЯВЛЕННАЯ ФУНКЦИЯ VS ФУНКЦИОНАЛЬНОЕ ВЫРАЖАНИЕ.


// Пример ОБЬЯВЛЕННАЯ ФУНКЦИЯ

function myFn(a, b) {
    let c
    a = a + 1
    c = a + b
    return c
}
// Создастся переменная myFn с значением ФУНКЦИЯ.

// Пример ФУНКЦИОНАЛЬНОЕ ВЫРАЖАНИЕ

// function(a, b) {
//     let c
//     a = a + 1
//     c = a + b
//     return c
// }
// Сдедовательно, ФУНКЦИОНАЛЬНЫЕ ВЫРАЖЕНИЯ ВСНГДА АНОНИМНЫЕ!!!

// Если в такой функции нету return тогда функция вернет undefined!

// Отличие в том что у второй функции НЕТ ИМЕНИ!!!


// ПРИСВАИВАНИЕ ФУНКЦИОАНЛЬНОГО ВЫРАЖЕНИЯ ПЕРЕМЕННОЙ!


const myFunction = function(a, b) { // Анонимное функциональное выражение.
    a = a + 1
    c = a + b
    return c
    
}

myFunction(5, 3) //9

// Мы присваиваем анонимное функциональное выражение переменной.


// ФУНКЦИОНАЛЬНОЕ ВЫРАЖЕНИЕ В ВЫЗОВЕ ДРУГОЙ ФУНКЦИИ

// В данном случае нет смысла нашу функцию называть, потому используем аноним функцию.
setTimeout(function() {
    console.log('Отложенное сообщение')
}, 1000)
// 'Отложенное сообщение' будет выведено в консоль через 1000 мс (1 сек)

// Встроенная функция setTimeout вызовет нашу функцию через 1 сек.
// В функции setTimeout первым аргументом передается колбек функция, и вторым аргументом передается через сколько сек запцтить первый аргумент.


//////////////////////////////   СТРЕЛОЧНЫЕ ФУНКЦИИ!!!   //////////////////////////////

// СТРЕЛОЧНЫЕ ФУНКЦИИ, это функции которые имеют немного другой синтаксис и не имеют ключевого слова function!

// Пример.

// У стрелочной функции ИМЕНИ НЕТУ!!!
// Стрелочная функция сразу начинается с параметров ()!
// Функция может не иметь параметров.
// Тело функции аналогичное с бычной function.

// (a, b) => {
//     let c
//     a = a + 1
//     c = a + b
//     return c
// }
// Стрелочная функция ЭТО ВЫРАЖЕНИЕ!!!
// СТРЕЛОЧНВЕ ФУНКЦИИ ВСЕГДА АНОНИМНЫЕ, и за того что у них нету имени!!!
// Они чем-то похоже на функциональное выражение, но в функциональном выражении есть ключевое слово function.


const myFunction2 = (a, b) => {
    let c
    a = a + 1
    c = a + b
    return c
}
// Имя же дать можно СТРЕЛОЧНОЙ ФУНКЦИИ, ПУТЕМ ПРИСВАИВАНИЯ К ПЕРЕМЕННОЙ!


myFunction(5, 3) // 9

// Почему же стоит делать именно таким образом, использвать функцию присвоенную к переменной.

// Когда мы используем СТРОЕЛОЧНУЮ функцию или функциональное выражение,
// мы используем const а значит не сможем случайно перезаписать функцию!!!

// ЕСЛИ МЫ ОБЬЯВЛИ ФУНКЦИЮ ЧЕРЕЗ function И ДАЕМ СРАЗУ ИМЯ ЭТОЙ ФУНКЦИИ,
// ТАКУЮ ФУНКЦИЮ МЫ МОЖЕМ СЛУЧАНОЙ ПЕРЕЗАПИСАТЬ, МЕРЕЗАПИСАВ ПЕРЕМЕННУЮ ГДЕ ХОАНИТСЯ ФУНКЦИЯ!!!


// СТРЕЛОЧНАЯ ФУНКЦИЯ В ВЫЗОВЕ ДРУГОЙ ФУНКЦИИ!


setTimeout(() => {
    console.log('Отложенное сообщение')
}, 1000)





//////////////////////////////   СОКРАЩЕНИЯ В СТРЕЛОЧНЫХ ФУНКЦИЯХ!   //////////////////////////////


// Вариант сокращения номер 1.


// Если один параметр, то круглые скобки можно опустить!!!

//  Без скобок.
_a => {
    // Тело функции
}

// С скобками.
(_a) => {
    // Тело функции
}
// Лучше добалять всегда скобки () чтобы код был более читабелен!




// Вариант сокращения номер 2.

// Фигурные скобки можно опустить, если тело функции состоит из одного выражения!
(a, b) => a + b
// ВАЖНО! В этом случае стрелочная функция НЕЯВНО ВОЗВРАЩАЕТ результат выражения!!!!!!

// То есть если есть скобки {} в стрелочной функции нужен return для возврата!!!! Если собок НЕТУ будет НЕЯВНЫЙ ВОЗВРАТ ФУГКЦИИ!!!

const myFn = (a, b) => a + b // НЕЯВНЫЙ ВОЗВРАТ!!!! return НЕ нужен.
// Эта функция сложит a + b и БЕЗ return ВЕРНЕТ результат функции.
// Если в функции одно выражение a + b то можно ее использовать! Очень удобынй вараинт!


console.log(myFn(45, 67)) // 112




//////////////////////////////   ЗНАЧЕНИЯ ПАРАМЕТРОВ ФУНКЦИЙ ПО УМОЛЧАНИЮ!   //////////////////////////////

// То есть мы можем установить значение второго аргумента если он не будет внесен при вызове функции в аргументах.

// Пример номер 1

// Дефолтная функция с ключевым словом function
function multiByFactor(value, multiplier = 1) {
    return value * multiplier
}

multiByFactor(10, 2) // 20
multiByFactor(5) //5 Здесь сработает multiplier = 1 и вместо второго аргумента, подставит число 1.



// ФУНКЦИОНАЛЬНОЕ ВЫРАЖЕНИЕ присвоено переменной.
const multiByFactor = function(value, multiplier = 1) {
    return value * multiplier
}



// СТРЕЛОЧНАЯ ФУНКЦИЯ с дефолтными параметрами + ЯВНЫЙ ВОЗВРАТ return.
const multiByFactor = (value, multiplier = 1) => {
    return value * multiplier
}


// СТРЕЛОЧНАЯ ФУНКЦИЯ с дефолтными параметрами + НЕ ЯВНЫЙ ВОЗВРАТ БЕЗ return.
const multiByFactor = (value, multiplier = 1) => value * multiplier


// Функция написана 4-термя вариантами, если в функции одно выражение, пишем через стрелку без {} скобок!



// Не ЯВНЫЙ возвоат функции!!!
// Если одно выражение, в данном примере a * b пишем с НЕ ЯВНЫЙ возвратом.
const testFn = (a, b) => a * b

const result = testFn(4, 7)

console.log(result) // 28



// ЯВНЫЙ возврат функции!!!
// Пишем так, если в теле функции больше одного выражения!
const testFn2 = (a, b) => {
    return a * b
}

const result2 = testFn2(44, 7)

console.log(result2) // 308



////////////////////////////////////////////////////////////////////////////////////////////

// Пример номер 2 НЕ ЯВНЫЙ возврат обьекта!!!


const newPost = (post, addedAt = Date()) => ({
    ...post,
    addedAt,
})
// Сокращенный формат записи объекта!!! post: post, addedAt: addedAt.
// Совпадает название свойства обьекта и параметра функции.

const fristPost = {
    id: 1,
    author: 'Vlad'
}

// newPost(fristPost)

console.log(newPost(fristPost))

// 1. Это стрелочная функция, которая присвоена к переменной newPost.
// 2. Мы берем оригинальный обьект newPost и хотит к нему добавить свойство addedAt.
// 3. Это ствойство addedAt должно иметь значение данного поста, дату вызова функции.
// 4. У этой функции есть 2 параметра, post (ссылка на обьект) и дефолтное значение addedAt = Date().
// 5. Мы использовали Date() это вызов функции которая присвоится к свойству addedAt.
// 6. Функция Date() есть в JS по умолчанию, при вызове данной функции мы получаем текущею дату.
// 7. Новый синтаксис => ({ ...post, addedAt }) почему скобки?
// 8. Задача этой функции, вернуть новый обьект не мутируя орги обьект через оператор спред "..."
// 9. Мы хотим вернуть обьект неявно, но если мы напишем {} фигурные скобки без () JS подумает ЧТО {} ЭТО ТЕЛО ФУНКЦИИ!!!
// 10. Если мы хотим неявно вернуть обьект, мы должны такой обьект обернуть в скобки ({обьект}).
// 11. Важно, у параметра addedAt зачения будут менятся, зависимо от текущей даты!


// Шаг 1. Вызов функции newPost, передача обьекта fristPost в параметр post.
// Шаг 2. В момент вызова функции new(fristPost) происходит присваивания значания параметру addedAt.
// Шаг 3. Это значение будет сформировано исходя из текущей даты с помощью вызова функии Date().
// Шаг 4. Функция Date() вернет текущую дату, мы добавим эту дату как значение для свойства addedAt.



// Пример номер 3 ЯВНЫЙ возврат обьекта!!!

const newPost2 = (post, addedAt = Date()) => {
    return {
    ...post,
    addedAt,
    }
}



const fristPost2 = {
    id: 1,
    author: 'Vlad'
}


console.log(newPost2(fristPost2))


//////////////////////////////   ОБРАБОТКА ОШИБОК!   //////////////////////////////



const fnWithError2 = () => {
    throw new Error('Some error')
}
// Генерация ошибки в JS

fnWithError2()
// Выполнение кода остановится в момоент вызова функции!
// ЭТО БУДЕТ АНКОД ОШИБКА, НЕ ПОЙМАННАЯ ОШИБКА!

console.log('Continue...') // Этот лог уже не выполнится!
// Как только мы получаем ошибку, далее код не используется и не анализируется.


////////// Как боротся с такими ошибками?



//////// TRY/CATCH
try {
    // Выполнение блока кода.
} catch (error) {
    // Этот блок выполнется в случае возникновения ошибок в блоке try!
}
//////// TRY/CATCH

// 1. В блок try мы должны поместить блок кода в котором может быть ошибка.
// 2. Если в блоке try возникает ошибка, она попадает во второй блок catch!
// 3. И все что находится во втором блоке catch, будет выполнено.


const fnWithError = () => {
    throw new Error('Some error')
}

try {
fnWithError()
} catch (error) {
    console.error(error) // Вывод ЦЕЛОЙ ошибки в консоль. Ошибка будет присвоена как значение к переменной catch (error)
    console.log(error.massage) // Вывод только СООБЩЕНИЯ об ошибки. Some error
}
// try это ловить :) Пойманная ошибка.
// Ошибка является по сути обьектом!!! У которого будет свойство error: значение то что напишет ошибка.

console.log('Continue...')
// Если мы словили ошибку, код ниже ошибки продолжит выполнятся!
// Для чего и нужен try/catch блок.

// Очень рекомендуется, все блоки кода, где могут возникать ошибки помещать в try/catch блок.
// Чтобы поймать ошибку, ошибку можно отправить на сервер, после чего код продолжит свое выполнение.



//////////////////////////////   ИНСТРУКЦИИ!!!   //////////////////////////////


// 1. Выражение - (всегда возвращает значение.)
// 2. Интсрукции - (let a это инструкция и if () {}.)
// 3. ВЫРАЖЕНИЕ - ИНСТРУКЦИЯ.


// ВЫРАЖЕНИЕ ВСЕГДА ВОЗВРАЩАЕТ ЗНАЧЕНИЕ!
// ФУНКЦИЯ ВСЕГДА ВОЗВРАЩАЕТ ЗНАЧЕНИЕ ИНСТРУКЦИЯ ЖЕ ВЫПОЛНЯЕТ ОПРЕДЕЛЕННЫЕ ДЕЙСТВИЯ.

// let a;
// Инструкция, обьявление переменной "a" (инструкция)
// Каждую инструкцию сделует заканчивать точка с запятой " ; "

// const b = 5;
// Вторая инструкция.

if (a > b) {
    console.log('a is larger');
}
// Инструкция if которая выполняет действия, но не требует " ; "

for (let i = 0; i+=1; i < 5) {
    console.log(i);
}
// Цикл, так же ИНСТРУКЦИЯ, но не требует " ; "

// То есть в этом примере 4 иструкции.

// То что заканчивается, {} for, if, не нужно " ; "


// ИНСТРУКЦИЯ ОБЫЧНО ЗАКАНЧТВАЕТСЯ точкой с памятой " ; "
// Это то как можно отлечить инструкцию от выражения.
// Исключение: " ; " не требуется после блока инструкции if, for.
// Точку с запятой " ; " можно опускать в JS.


//////////////////////////////   ВЫРАЖЕНИЯ МОЖЕТ БЫТЬ ИНСТРУКЦИЕЙ!!!   //////////////////////////////


// Пример

'abc'

a = a + 3;
// Это выражерние выполняется оодельно от других, если добавим " ; " будет (Выражение - Инструкция)

c = a + b;

d = 'Good' + 'Eventing';

myFunction(c, d);
//Функция всегда вернет значение, это в первую очередб выражение!!! (Выражение - Инструкция)

console.log('Hey');

// ИНСТРУКЦИЯ НЕ МОЖЕТ БЫТЬ ТРАНСФОРМИРОВАНА В ВЫРЫЖЕНИЕ!!!




// КАК ОТЛИЧАТЬ, ГДЕ ВЫРАЖЕНИЕ А ГДЕ ВЫРАЖЕНИЕ - ИНСТРУКЦИЯ?

// Как проверить???
// ВЫРАЖЕНИЯ МОГУТ БЫТЬ ИСРОЛЬЗОВАНЫ КАК АРГУМЕНТЫ В ВЫЗОВАХ ФУНКЦИЯХ! myFunction(c, d);
// СООТВЕСТВЕННО ИНСТРУКЦИИ НЕ МОГУТ БЫТЬ ИСПОЛЬЗОВАННЫ КАК АРГУМЕНТЫ В ФУНКЦИЯХ.


function myFn(a) {
    console.log(a);
}

const t = true;
let c = 10;

myFn(2 + 3) //5
myFn(t) // true
myFn(c = c + 1) // 11
//myFn(c = c + 1;) // Конвентируем в ИНСТРУКЦИЮ, ИНСТРУКЦИЮ нельзя передавать как аргумент в функции!
//myFn(let t) // Инструкция, нельзя передавать как аргумент в функцию!

// Выражение ВСЕГДА ВОЗВРАЩАЕТ ЗНАЧЕНИЕ!!!

// Точка с запятой " ; " ставится после всех и нтрукций!!!
// Разные иструкции должны находится на разных строках кода!!!



//////////////////////////////   МАССИВЫ!!!   //////////////////////////////


// Массив это ОБЬЕКТ с ЦИФРОВЫМИ ИМЕНАМИ СВОЙСТВ!!!

// 1. Свойства у массива называются 1, 2, 3 и тд, в зависимрсти от количества элементов в массиве.

// Массив так же часто используют как обьект НО массив это ОБЬЕКТ!

// Формат записи массива, два арианта синтаксиса.


// Создание массива вариант 1
// Создание массива и присваивание массива в переменную myArray.
const myArray = [1, 2, 3]
console.log(myArray)
// [1, 2, 3]

// Создание массива вариант 2
// Создание путем нового эекземпляра класса new Array, классы начинаются с ЗАГЛАВНОЙ буквы!
// С помощью "new" можно создавать новые екземпляры классов.
const myArray2 = new Array(1, 2, 3)
console.log(myArray2) // [1, 2, 3]
// Вызываем функцию Array и передаем в нее аргементы.

// В массив один можно добавлять разные значения, строки, числа, буливые значения и тд.
// В данном примере все значения типа namber, число.

// Если сравнить эти два массива
myArray === myArray2
// false так как разные ссылки на разные массивы/обьекты в памяти.

// Массив это ОБЬЕКТ а ОБЬЕКТ ЭТО ССЫЛОЧНЫЙ ТИП! Потому myArray === myArray2 (false)


// Эти два масисива будут созданы в разных ячейках памяти, и не важно что внутри массива!
// Потому массивы не равны друг другу!

// myArray === myArray2 не равны друг другу так как содержат разные ссылки на эти два обьекта.


// СТРУКТУРА МАССИВА, внутри как обьект.

// [1, 2, 3]
//   0:	1
//   1: 2
//   2:	3
// length: 3 // Длинна массива
// [[Prototype]]: Array(0)

const myArray3 = myArray
//Копия по ссылки которая присвоится переменной myArray3 на массив myArray

console.log(myArray === myArray3)
// Ответ true, так как мы скопировали ссылку на один и тот же массив!


//////////////////////////////   МАССИВ ПРОТИВ ОБЬЕКТА!!!   //////////////////////////////

// Прототип МАССИВ
const myArray4 = [1, 2, 3]
// [1, 2, 3]
//   0:	1
//   1: 2
//   2:	3
// length: 3 // Длинна массива
// [[Prototype]]: Array(0)


// Прототип ОБЬЕКТ
const myObject = {
    0: 1,
    1: 2,
    2: 3,
    length: 3
}
// {0: 1, 1: 2, 2: 3, length: 3}
// 0: 1
// 1: 2
// 2: 3
// length: 3
// [[Prototype]]: Object


// Именно ПРОТОТИПЫ влиют на то какие методы становтся дотсупные для обьекта и массивов!
// У ОБЬЕКТОВ и МАССИВОВ разные ПРОТОТИПЫ потому разное поведение.
// У Массива length: 3 меняется в зависимости от длинны массива, у обьекта length: 3 не меняется.





// Индекс последнего элемента
// Чаще всего мы заранее в коде не знаем какая будет длина массива. 
// Для того чтобы получить значение последнего элемента применяется следующий подход - длина массива всегда на единицу больше чем индекс последнего элемента. 
// Используя формулу длина_массива - 1 можно получить значение последнего элемента массива произвольной длины.







//////////////////////////////   КАК РАБОТАТЬ С ЭЛЕМЕНТАМИ МАССИВА!!!   //////////////////////////////

const myArray5 = [1, true, 'abc']
console.log(myArray5) // [ 1, true, 'a' ]

console.log(myArray5[0]) // 1
console.log(myArray5[1]) // true

console.log(myArray5.length) // 3
// length это длинна массива!

// Если мы хотим обратится в определенному свойству массива, нам нужны скобки []
// Если свойства у массива цифровые, мы не можем обратится через точечную запись.

// (myArray5.0 НЕ РАБОТАЕТ!!!

// myArray5[0]
// Обращение к индексу 1 ответ true
// Обращение к индексу 0 ответ 1
// Обращение к индексу 2 ответ 'abc'

// Едиственные способ доступа к индексу массива через квадратные скобки []


// Поменять значение в массиве можно так.

myArray5[0] = false

console.log(myArray5)
// [false, true, 'abc']

// ПОРЯДОК ЭЛЕМЕНТОВ В МАССИВЕ ВАЖЕН!!! ТАК КАК МАССИВ ИМЕЕТ ИНДЕКСЫ ПОД КОТОРЫМИ НАХОДЯТСЯ ЗНАЧЕНИЯ!!!
// КАЖДЫЙ ЭЛЕМЕНТ ИМЕЕТ СВОЙ ПОРЯДКОВЫЙ НОМЕР, ИНДЕКС!

// МАССИВ  [false, true, 'abc']
// ИНДЕКС    0      1      2

// Добавление новых элементов в массив.



const myArray6 = [1, 2, 3, 4]

console.log(myArray6) // [ 1, 2, 3, 4 ]
console.log(myArray6.length) // 4

myArray6[2] = 'abc'
// Меняем значение под индексом 2 С значением 3 НА 'abc'

console.log(myArray6) // [ 1, 2, 'abc', 4 ]

myArray6[4] = true
// Дабавляем индекс 4 в конец массива под которым будет значение true.

console.log(myArray6) // [ 1, 2, 'abc', 4, true ]
console.log(myArray6.length) // 5
// Массив увеличился на 1 индекс, сейчас длинна массива 5.

// Чтобы таким методом добавлять элементы массива, НАМ НУЖНО ЗНАТЬ ТЕКУЩЮЮ ДЛИННУ МАССИВА, ЧТО НЕ УДОБНО!
// YНа помощь приходят методы массивов!




//////////////////////////////   МЕТОДЫ МАССИВОВ!!!   //////////////////////////////

// Эти методы называются функциями высшего порядка!

// 1. push  - (ДОБАВЛЯЕТ элемент в КОНЦЕ массива)
// 2. pop - (УДАЛЯЕТ элемент в КОНЦЕ массива и  ВОЗВРАЩАЕТ УДАЛЕННЫЙ ЭЛЕМЕНТ!
// 3. unshift - (ДОБАВЛЯЕТ елемент в НАЧАЛЕ массива)
// 4. shift - (УДАЛЯЕТ елемент в НАЧАЛЕ массива и  ВОЗВРАЩАЕТ УДАЛЕННЫЙ ЭЛЕМЕНТ)
// ВСЕ ЭТИ МЕТОДЫ puh, pop, shift, unshift МУТИРУЮТ ОРИГИНАЛЬНЫЙ МАССИВ!!!!!!
// 5. forEach - Метод forEach() перебирает массив НО НИЧЕГО НЕ ВОЗВРАЩАЕТ!
// 6. map - Метод map() перебирает И ВОЗВРАЩАЕТ НОВЫЙ МАССИВ на БАЗЕ ОРИГИНАЛЬНОГО!!!
// Методы forEach и map не мутируют оригинальный массив!

// Каждый массив который мы создаем, является экземпляром массива.
// В виде массивов это Array() c заглавной буквы A.
// В данном экземпляре Array() есть много методов, в том числе описанные выше!

// Мы можем вызывать любой метод используя точечную запись, после названия переменной которая содержит массив.




/////////////// МЕТОД puh (ДОБАВЛЯЕТ елемент в КОНЦЕ массива)

const myArray7 = [1, 2, 3, 4]
console.log(myArray7) // [ 1, 2, 3, 4 ]

myArray7.push(false)
// Добавляем В КОНЕЦ МАССИВА елемент false с помошью метода puh

console.log(myArray7) // [ 1, 2, 3, 4, false ]

myArray7.push(true)
// Добавляем В КОНЕЦ МАССИВА елемент true с помошью метода puh

console.log(myArray7) // [ 1, 2, 3, 4, false, true ]

// В переменной myArray7 лежит массив и он наследует все методы массивов.
// То есть мы вызвали puh как метод переменной myArray7 и переменная наследует все методы массивов.
// Потому мы можем вызвать любой метод используя точечную запись.

// Метод puh() в своих круглых скобках () ожидает элемент который будет добавлен в конце масиива.



/////////////// МЕТОД pop (УДАЛЯЕТ елемент в КОНЦЕ массива и  ВОЗВРАЩАЕТ УДАЛЕННЫЙ ЭЛЕМЕНТ!


const myArray8 = [1, 2, 3, 4]

console.log(myArray8) // [ 1, 2, 3, 4 ]

myArray8.pop()
// Удаляем последний елемент в массиве.

console.log(myArray8) // [ 1, 2, 3 ]

// ВАЖНО! Метод pop удаляет и ВОЗВРАЩАЕТ УДАЛЕННЫЙ ЭЛЕМЕНТ!!!!

const removedElement = myArray8.pop()
// Присваиваем результат метода pop переменной.
// В переменную removedElement присвоится последний, удаленный елемент массива.

console.log(myArray8) // [ 1, 2 ]
console.log(removedElement) // Метод pop вернул удаленно значение 3

// Метод pop удаляет елемент с конца массива и возвращает удаленный элемент!!!





/////////////// МЕТОД UNSHIFT (ДОБАВЛЯЕТ елемент в НАЧАЛЕ массива)

// ВАЖНО! Все осталные элементы сдвинутся, ИНДЕКСЫ ИЗМЕНЯТСЯ!

// МЕТОД UNSHIFT используется редко.

const myArray9 = [1, 2, 3]

console.log(myArray9) // [1, 2, 3]

myArray9.unshift(true)
// Добавлили елемент true в НАЧАЛЕ массива.
// ВАЖНО! Все осталные элементы сдвинутся, ИНДЕКСЫ ИЗМЕНЯТСЯ!

console.log(myArray9) // [ true, 1, 2, 3 ]

myArray9.unshift('abc')
// Добавлили елемент 'abc' в НАЧАЛЕ массива.

console.log(myArray9) // [ 'abc', true, 1, 2, 3 ]




/////////////// МЕТОД SHIFT (УДАЛЯЕТ елемент в НАЧАЛЕ массива)



const myArray10 = [1, 2, 3]

console.log(myArray10) // [1, 2, 3]

myArray10.shift()
// УДАЛИЛИ елемент в НАЧАЛЕ массива/

console.log(myArray10) // [ 2, 3 ]


const removedElement1 = myArray10.shift()
// УДАЛЯЕМ елемент 2 в НАЧАЛЕ массива и  ВОЗВРАЩАЕМ УДАЛЕННЫЙ ЭЛЕМЕНТ в переменную removedElement1!

console.log(myArray10) // 3
console.log(removedElement1) // 2


// То есть можно присвоить результат метода SHIFT или pop какой-то переменной.


// ВСЕ ЭТИ МЕТОДЫ puh, pop, shift, unshift МУТИРУЮТ ОРИГИНАЛЬНЫЙ МАССИВ!!!!!!
// МАСИВ ЭТО ОБЬЕКТ, А ОБЬЕКТ ЭТО ССЫЛОЧНЫЙ ТИП!!!! Потому может муьтровать даже если переменная const.

// В переменной харанится только ссылка на массив!!!

// Мы как бы переходим по ссылке которая лежит const myArray10 после чего мутируем массив!






//////////////////////////////   МЕТОД FOREACH!!!   //////////////////////////////

// Метод forEach() перебирает НО НИЧЕГО НЕ ВОЗВРАЩАЕТ!

const myArray11 = [1, 2, 3]
console.log(myArray11) // [ 1, 2, 3 ]

myArray11.forEach((el) => console.log(el * 2))
// Результат перебора 2, 4, 6
// Не явный возврат колбек функции (el * 2)

// 1. Метод forEach() в его аргумент () передается колбек функция!
// 2. Метод forEach будет перебирать все элементы массива.
// 3. Для каждого элемента массива, метод forEach будет вызывать функцию которую передали в его аргемент ().
// 4. В параментр el будет передаваться значение определенного элемента массива. То есть el на первой етирации будет содержать 1 на втоой 2, на третей 3.
// 5. При каждой етерации значение которое находится в el будет умножено на 2.

// То есть в методе forEach(), внутри скобок находится цикл, который перебирает все элементы массива, и вызывает колбек функцию столько раз, сколько есть элементов в массиве.

console.log(myArray11) // [ 1, 2, 3 ]
// Оригинальный массив не изменился.



//////////////////////////////   МЕТОД MAP!!!   //////////////////////////////

// Метод map() перебирает И ВОЗВРАЩАЕТ НОВЫЙ МАССИВ на БАЗЕ ОРИГИНАЛЬНОГО!!!
// Аналогично ожидает в своих аргументах () колбек функцию.


const myArray12 = [1, 2 ,3]
console.log(myArray12) // [ 1, 2, 3 ]

const newArray = myArray12.map((el) => el * 3)

console.log(newArray) // Вернул новый массив [ 3, 6, 9 ]
console.log(myArray12) // Оригинальный массив [ 1, 2, 3 ]
// Оригинальный массив не изменился!

// 1. Метод map() как и в forEach() перебирает масив столько раз, сколько элементов в массиве.
// 2. Елементы кторые перебрал, хранит в параметре el. 
// 3. Ожидает в параметрах () колбек функцию, которая будет что-то делать с элементами el.
// 4. В данном примере map((el) => el * 3) то есть каждое число, которое находится в el умножить на 3.
// ВАЖНО!!! Метод map() ВОЗВРАШАЕТ НОВЫЙ МАССИВ!!!!!!

// То есть рузультат перебора мы можем поместить в переменную как новый массив в котром будут елементы с оригинального массива перемноженные на 3.
// ВАЖНО!!! map() формирует НОВЫЙ МАССИВ исходя из результата колбек функии которую мы положили в параметры () метода map.
// В данном примере то что колбек функция НЕ ЯВНО возвращает, то и будет записано в новый массив в качестве элементов.

// Имеет смысл присваивать результат вызова метода map новой переменной! const newArray = myArray12.map((el) => el * 3) новый массив будет находится в переменной newArray.
// В тоже время оригинальный массив не изменится.
// Метод map() всегда вернет массив той же длинны что и оргинальный.


// ОТЛИЧИЯ map() forEach.

// 1. forEach просто выполняет действия с каждым елементом массива.
// 2. map() возвращает новый массив на базе оригинального, при этом оригинальный массив не изменится!

// map() И forEach НЕ изменяет оригинальный массив!


// Несколько вариантов написания колбек функции.

// Пример 1

const newArray13 = myArray12.map((el) => {
    return el * 3
})
// Явный возврат через {return}


// Пример 2

const newArray14 = myArray12.map(function (el) {
    return el * 3
})
// Здесь анонимная функция, сократить и убрать return не получится.
// Сократить колбек функцию можно только в стрелочных функциях =>





//////////////////////////////   ДЕСТРУКТУРИЗАЦИЯ ОБЬЕКТОВ!!!   //////////////////////////////


// Допустим у нас есть обьект, и этому обьекту мы хотим присвоить несколько совойст обьекта новым переменным.
 const userProfile = {
    name: 'Vlad',
    commentsQty: 23,
    hasSignedAgreement: false,
 }

 const {name, commentsQty} = userProfile
 const {hasSignedAgreement} = userProfile
 // 1. Обьявляем переменные.
 // 2. Присваиваем им значение на основе значений свойств обьекта.
 // 3. Автоматически будут обьявлены переменные name, commentsQty, hasSignedAgreement.
 // 4. Значение в эти переменные запишется с обьекта userProfile.

 // То есть в переменная name содержит строку 'Bogdan', переменная commentsQty число 23 и hasSignedAgreement значение false.

 console.log(name) // Bogdan
 console.log(commentsQty) // 23
 console.log(hasSignedAgreement) // false


// 1. То есть говорим JS, мы хотим взять из обьекта userProfile значение свойств name и commentsQty.
// 2. Создать новые переменные с такими же именами name и commentsQty.
// 3. И присвоить им значение, значение соответствующих свойств в этом объекте.

// Обьявление переменных и присваивание им значения происходит на одной строке!
// Это называется деструктуризация обьектов.



//////////////////////////////   ДЕСТРУКТУРИЗАЦИЯ МАССИВОВ!!!   //////////////////////////////

// Можно похожим образом создавать новые переменные и присвоить им значение на основании значений элементов массива!
// Отличие в том что в обьектах мы использовали фигурные скобки, в массивах используем квадратные скобки.

// Помним что порядок в массивах ВАЖЕН!! В обьектах НЕ важен.

const fruits = ['Apple', 'Banana']
// У переменной 'Apple' индекс будет "0" и у переменой 'Banana' индекс 1.
// В такой последовательности будут присвоины переменные.

const [fruitOne, fruitTwo] = fruits
// Присваиваем значение 'Apple' в переменную fruitOne и значение 'Banana' в переменную fruitTwo.
// Если значения в массиве 'Apple' и 'Banana' поменять местами то и переменные будут присвоины наоборот.

console.log(fruitOne) // Apple
console.log(fruitTwo) // Banana

// Важно учитывать порядок следования элементов в массиве!
// Это главное отличие кроме скобок в деструктуризации обьектов МАССИВОВ от деструктуризации ОБЬЕКТОВ!



//////////////////////////////   ДЕСТРУКТУРИЗАЦИЯ ПАРАМЕТРОВ ФУНКЦИИ!!!   //////////////////////////////


const userProfile1 = {
name: 'Vlad',
commentsQty: 23,
hasSignedAgreement: false
}

const userInfo = ({name, commentsQty}) => {
if (!commentsQty) {
return `User ${name} has no comments`
}
// Деструктуризация параметров обьекта ({name, commentsQty})
// Если не comments или comments равна нулю выводим первую строку, если comments то выводим вторую строку.

return `User ${name} has ${commentsQty} comments`
}

userInfo(userProfile1)

console.log(userInfo(userProfile1)) // User Vlad has 23 comments

// 1. Вызываем функцию userInfo в параметры функции передаем обьект userProfile1.
// 2. Обьект приходит в функцию userInfo по ссылке, обьект ссылочный тип.
// 3. И непосредственно в блоке параметров, мы можем выпонить деструктуризацию свойств из обьекта userProfile1 строка ({name, commentsQty}).

// Мы хотим взять свойства name: и commentsQty: из значения которые будут переданы в вызове функции а это обьект.
// Создать новые переменные с названиями name и commentsQty.
// И присвоить им соотвествущие значения, значения name: 'Vlad' и commentsQty: 23

// То есть на входе, у нас будет переменная name и ее значение 'Vlad' и переменная commentsQty и ее значение 23.
// После чего внутри функции можно оперировать с этими переменными.

// Параметр это и есть переменная значение которых меняется при вызове функции.
// Функции часто получают обьект на мето параметров.






//////////////////////////////   УСЛОВНЫЕ ИНСТРУКЦИИ if else!!!   //////////////////////////////


// 1. if
// 2. if...else
// 3. else...if
// 4. switch
// Тернарный оператор (тернарник используется в выражениях а выражение возвращают результат)



//////////////////////////////   ИНСТРУКЦИЯ IF!!!   //////////////////////////////

// Помним что инструкция в JS выполняет определенные действия!
// Выражение возвращает результат!

// Как легко проверить инструкция или выражение? В любую функцию в параметры добавить то что хотим проверить.

// Условие это выражение. Любое выражение возвращает значение.
if (Условие) {
  // Блок кода, выполняемый
  // однократно, если Условие правдиво.
}

// Если значение которое возвращает это (Условие) ложно то тогда такой блок инструкции не выполнится.

// Помним ложные значения.

// 1. 0 - ноль.
// 2. '' - любая пустая строка.
// 3. false - ложное значение.
// 4. undefine - неопределенно.
// 5. NaN - не число.
// 6. null - пусто.


// Но если при конвертации к булевому значению это условие правдиво,
// тогда этот блок иснтрукции выполняется.

// Как приводить к булевому значению!

// 1. Использовать двойной оператор НЕ !! пример (!!'abc' не не строка)
// 2. Boolean(значение)

// Это выполняет инструкция IF внутри себя!

// Помним что операторы +=, -=, >, !=, < сразу возвращает булевое значение!

// Пример 1
let val = 10

if (val > 5) {
    val += 20
}

console.log(val) // 30


// Пример 2
const person = {
    age: 20
}

if (!person.name) {
    console.log('Имя не указано')
    // Другие действия в случае, 
    // если свойства 'name' у обьекта 'person' нету
}
// Под капотом у if !undefined === true
// Если мы пробуем получить доступ к свойству которого нету в обьекте, ответ будет undefined.

// 1. Проверяем есть ли name в обьекте person.
// 2. Если name нету или ложно, выполняем console.log('Имя не указано')
// 3. Если есть в обьекте person имя name, тогда выполняем другие действия.

// Если в условии будет НЕ пустая строка !"", ответ тоже будет true.



//////////////////////////////   ИНСТРУКЦИЯ IF ELSE!!!   //////////////////////////////

// В иструкции if else уже 2 блока кода!

if (Условие) {
    // Блок кода, выполняемый 
    // однократоно, если Условие правдиво
} else {
    // Блок кода, выполняемый 
    // однократоно, если Условие ложно
}

// 1. Блок когда if выполняется если условие правдиво.
// 2. Блок кода else выполняется если блок кода ложно.
// Важно! Выполнится либо 1-первый блок кода либо 2-торой!
// Блок выполнится однократно.

// Пример 2

let valu = 10

if (valu < 5) {
valu +=20
} else {
    valu -= 20
}

console.log(valu) // -10



//////////////////////////////   ИНСТРУКЦИЯ IF ELSE IF !!!   //////////////////////////////

// Вариант написания 1

if (Условие1) {
// Блок кода, выполняемый
// однократно, если Условие 1 правдиво.
} else if (Условие2) {
// Блок кода, выполняемый
// однократно, если Условие 2 правдиво.
} else {
    // Блок кода, выполняемый
    // однократно, если предыдущие условия ложны
}

// 1. Выполница блок кода 1 if если Условие 1 правдиво.
// 2. Выполница блок кода 2 if если Условие 2 правдиво.
// 3. else выполница если предыдущие условия ложны.
// Переходим к блоку if 2 если блок if 1 ложно.



// Вариант написания 2

// В этом варианте нужно в условиях которые находятся в разных блоках учитывать так же предыдущие условия,
// если мы хотим выполнить только один из этих блоков.

if (Условие1) {
// Блок кода, выполняемый
// однократно, если Условие 1 правдиво.
}


if (Условие2) {
    // Блок кода, выполняемый
    // однократно, если Условие 2 правдиво.
    }


    if (Условие3) {
        // Блок кода, выполняемый
        // однократно, если Условие 3 правдиво.
        }


// Пример if...else...if
 const age = 25

if (age > 18) {
    console.log('Is adult')
} else if (age >= 12) {
console.log('Is teenager')
} else {
    console.log('Is child')
}

// 1. Провреяем значение переменной age.
// 2. Если age больше 25 выводим console.log('Is adult')
// 3. Если age находится с диапазоне от 18 до 12 выводим console.log('Is teenager')
// 4. Если меньше 12, значит 2 выше блока ложны выводим console.log('Is child')


// Пример IF, IF, IF

// Проверка на возраст.

const age2 = 25

if (age2 >= 18) {
    console.log('Is adult')
} 

if (age2 >= 12 && age2 < 18) { // Диапазон от 12 до 18
console.log('Is teenager')
} 

if (age2 < 12) {
    console.log('Is child')
}

// Получается есть 3 диапазона.

// 1) от 0 до 12
// 2) от 12 до 18 с оператором И "&&"
// 3) от 18 и выше.

// Таким образом можно переписать IF else IF инструкции на просто IF интрукции.


//////////////////////////////   ИНСТРУКЦИЯ IF в ФУНКЦИЯХ !!!   //////////////////////////////

const sumPositiveNumbers = (a, b) => {
    if (typeof a !== 'number' || typeof b !== 'number') {
return 'One of the arguments is not a number'
    }

    if (a <= 0 || b <= 0) {
return 'Numbers are not positive'
    }

    return a + b
}

console.log(sumPositiveNumbers(12, 15))

// 1. Если тип параметров a, b НЕ число то возвращаем строку return 'One of the arguments is not a number'.      
// Если ТИП переменной "a" и "b" это число мы переходим к второй проверке.
// 2. Провреяем значение "a" и "b" если оно меньше или равно нулю, мы возвращаем строку return  'Numbers are not positive'


// Помним после ключевого слова return функция прекращает свою работу.
// Дальше функция не выполняется.

// В данном случае если условие номер 1 правдиво, вернется строка return  'One of the arguments is not a number',
// после чего функция прекратит свою работу.

// Если условие номер 1 ложно мы иде дальше. Если условие 2 правдиво, вернется строка return  'One of the arguments is not a number', 
// после чего функция прекратит свою работу.

// Если условие 1 и 2 ложно, то выполняется сложение чисел которые хрантся в переменных a + b, после чего функция прекратит свою работу.



//////////////////////////////   ИНСТРУКЦИЯ SWITCH !!!   //////////////////////////////

switch (Выражение) {
    case A:
        // Действия если Выражение === A
        break;
        case B:
            // Действия если Выражение === B
            break;
    default:
        // Действия по умолчанию.
        
}


// Пример Зимние месяца.

const month = 2 

switch (month) {
    case 12:
      console.log('Декабырь')
        break
    case 1:
        console.log('Январь')
        break
    case 2:
        console.log('Февраль')
        break
    default:
        console.log('Это не зимний месяц')
}

// Под капотом switch происходит сравнение!

// 1. month === case 12 ответ console.log('Декабырь')
// 2. month === case 1 ответ console.log('Январь')
// 3. month === case 2 ответ console.log('Февраль')

// Если нам ПОДОШЕЛ один из case мы выходим с инструкции и возвращаем результат case.
// Если нам НЕ подошел не один из case мы возвращаем блок default. 
// switch работает на строгое равенство "===" на больше ">" меньше "<" не работает!

// Если задача выпонять разные действия исходя из значений той или иной переменной
// тогда лучше использовать инструкцию switch нежели IF...else...IF.


//////////////////////////////   ТЕРНАРНЫЙ ОПЕРАТОР !!!   //////////////////////////////

// У тернарного оператора 3 опертанда а операторы возвращают значения!!!

// Есть разные операторы.

// 1. Унарные операторы - 1 операнд.
// 2. Бинарные операторы - 2 операнда.
// 3. Тернарные оператор - 3 операнда.

// Конструкция с тернарным оператором это ВЫРАЖЕНИЕ!
// А выражение всегда возвращает значение!

// Тернарный оператор можно использовать там, где нужно получить значение.
// Допустим присвоить значение переменной.

// Синтаксис

// Условие ? Выражение 1 : Выражение 2
// Это выражение!!!

// Тернарник вернет либо Выражение 1 либо Выражение 2, зависит от условия.

// Можно использовать любые операторы, строгое равенство "===", больше ">", меньше "<, НЕ равно "!==="

// 1. Если условие правдиво, тогда возвращается результат Выражения 1.
// 2. Если условие ложно, тогда возвращается результат Выражения 2.

// Это все можно написать на IF else/

if (Условие) {
    // Выражение 1
} else {
   // Выражение 2
}

// Отличие, в блоках кода IF else можно использовать и инструкции и выражение, 
// здесь же в тернарнике можно исполовать ТОЛЬКО ВЫРАЖЕНИЯ!

// То есть в тернарник нельзя засунуть другие инструкции.

// Тернарник a + b либо вызов myFn()
// If...else можно написать внутри блока другую инфструкцию, цикл допустим.

// Рекомендуется тернарник писать так.

// Условие
// ? Выражение 1
// : Выражение 2
// Это все выражение, вернет значение!


// Пример 1
const value = 11

value
? console.log('Условие истино')
: console.log('Условие ложно')

// Это выражение - иснтрукция.

// 1. Если value правдиво, то мы печатаем в консоль console.log('Условие истино')
// 2. Если value ложно, то мы печатаем в консоль console.log('Условие ложно')


// Пример 2

const value1 = 11
const valuse = 25

// value1 && value2 ? myFunction1(value1, value2) : myFunction2()

value1 && value2 
? myFunction1(value1, value2) 
: myFunction2()

// 1. Если value1 И value2 НЕ ложны мы мызываем функцию myFunction1(value1, value2)
// 2. Если value1 И value2 ложны тогда вызывается фугкция myFunction2()

// Вызов функции это выражение, потому мы можем вызывать фугкции внтури тернарника.
// Функция возвращает всегда значение.


// Пример 3


let value3 = 11
console.log(value3 >= 0 ? value3 : -value3) // 11

// 1. Здесь идет вызов метода log обьекта console.
// 2. В вызове метода, мы используем конструкцию с тернарным оператором.
// 3. Условие value3 >= 0
// 4. Будет выполнено value3 если условие правдиво.
// 5. Если условие ложно, будет выполнено -value3.
// 6. Выражение тернарника в данном привере вернут 11.

// Пример 4

const value4 = -5
const res1 = value4 >= 0 ? value4 : -value4
console.log(res1)



//////////////////////////////   ЦИКЛЫ !!!   //////////////////////////////


// Цикл нужен чтобы уйти от повторяющего блока кода, чтобы один блок кода можно было переиспользовать.

// Пример 

// let i = 0
// console.log(ii)
// i+=1
// console.log(ii)
// i+=1
// console.log(ii)
// i+=1
// console.log(ii)
// i+=1
// console.log(ii)
// i+=1

// Перебор всех элементов МАССИВА без цикла.
const myArray5 = [true, 'abc', 10]

console.log(myArray5[0]) // true
console.log(myArray5[1]) // abc
console.log(myArray5[2]) // 10
// Перебор всех элементов массива без цикла.




// Перебор всех свойств ОБЬЕКТА без цикла.
const myObject1 = {
    x: 10,
    y: true,
    z: 'abc'
}

console.log(myObject1.x) // 10
console.log(myObject1.y) // true
console.log(myObject1.z) // abc
// Перебор всех свойств ОБЬЕКТА без цикла.




// Так вот для перебора, есть разные виды ЦИКЛОВ.


// 1. for
// 2. for...in...
// 3. while
// 4. do...while
// 5. for...of...






//////////////////////////////   ЦИКЛЫ FOR !!!   //////////////////////////////


// Все ЦИКЛЫ это ИНСТРУКЦИИ НЕ выражения!


// for (Начальная инструкция: Условие; Интерационное действие) {
// // Блок кода, выполняемый НА КАЖДОЙ ИТЕРАЦИИ
// }

// В IF...else блок кода выполнялся однократно.
// В цикле один итот же блок кода выполняется многократно НА КАЖДОЙ ИТЕРАЦИИ!!!!!!!!
// Зависима от конечества итераций.


for (let i = 0; i < 5; i+=1) {
    console.log(i)
} // вывод 0 1 2 3 4

// В цикле for 3 инструкции;

// 1) let i = 0;  - даем переменную i назначаем начальное значение 0
// 2) i < 5;  -   здесь 0 сравнивается с 5 "0 < 5" будет true 
// 3) Переходим в блок кода и печатаем console.log(i) хначение переменной i.
// 4) Это была итерации, после ее окончания  мы увеличиваем i на 1.
// 4) i+=1  - здесь происходит увелечение i на 1
// 5) i теперь становится 1
// 6) Перед второй итерацией мы смотрим на это усллвие i < 5
// 7) Чтобы мы пошли в следующюю итерациюю i должно быть меньше 5-ти.
// 8) i сейчас 1 а 1 меньше 5-ти следовательно мы смнова идем в блок кода где печатаем console.log(i).
// 9) После второй итерации i увеличивается на 1 "i+=1" становится 2.
// 10) Проверяется "i < 5" меньше ли 2 чем 5, да меньше.
// 11) И снова мы попадаем в цикл, в третью итерацию и печатаем в консоль значение i console.log(i) это уже в консоле выводится цифра 2.
// И так далее до того как наша i станет 5 и 5 уже не меньше 5-ти блок "i < 5"
// 5 меньше 5-ти "i < 5" это условие ложно и мы выходим из цикла.
// Потому в консоле мы не увидим цифры 5. Блок "5 < 5" лож.
// Потому что когда i стала 5 мы вышли из цикла.

// Так работает цикл FOR.


// На практике мы будет перебирвать либо элементы массивов, либо свойства обьектов.
// Это можно сделать без цикла FOR.





//////////////////////////////  ДЛЯ ПЕРЕБОРА МАССИВА НЕ НУЖЕН ЦИКЛ FOR !!!   //////////////////////////////


// ЦИКЛ FOR МОЖНО ИСПОЛЬЗОВАТЬ ДЛЯ МАССИВОВ, НО НЕ РЕКОМЕНДУЕТСЯ!

// Нужно использовать функции высшего порядка массивов, такоие как
// "forEach", "map", "reduce" это методы прототипа массивов. Они доступны для каждого массива.


// Если все-таки попробовать перебрать циклом FOR массив то вот пример.

const myArray13 = ['first', 'second', 'third']

for (let i = 0; i < myArray13.length; i+=1) {
console.log(myArray13[i])
} // first, second, second.

// Для массивов все же лучше использова метод FOREACH




//////////////////////////////   ЦИКЛ forEach !!!   //////////////////////////////

const myArray14 = ['first', 'second', 'third']

myArray14.forEach((element, index) => {
    console.log(element, index)
}) // first 0, second 1, third 2

// Метод forEach вернет ЭЛЕМЕНТ и его ИНДЕКС.

// Метод forEach ожидает в сови параметры () колбек функцию, которая вызывается столько раз, сколько элементов в масииве!!!
// C forEach мы получаем не только доступ к элементу но и к его ИНДЕКСУ что в массивах важно.

// Воторой параметр опционален, если нам не нужен индекс.
// То есть можно оставить только один element в параметрах колбек функции.

// Колбек функция которая передается в качестве аргумента методу forEac БУДЕТ ВЫЗЫВАТЬСЯ СТОЛЬКО РАЗ, СКОЛЬКО ЭЛЕМЕНТОВ В ИСХОДНОМ МАССИВЕ!


// forEach создан чтобы перебирать местоды массива!! forEach Возвращает undefined.
// Потому нет смыслы присваивать результат вызова метода forEach переменной.



//////////////////////////////   ЦИКЛ WHILE !!!   //////////////////////////////


// ЦИКЛ WHILE позволяет выполнять блок кода, пока УСЛОВИЕ ПРАВДИВО.

// Цикл выполняется пока условие правдиво!!!
while (Условие) {
    // Блок кода, выполняемый на 
    // каждой итерации. 
}

// Блок инструкции (Может быть не разу не выполнен.)
// Если условие ЛОЖНО, то блок инструкции не выполнится ни разу.


// Если условие будет бесконечно правдиво, ЦИКЛ WHILE может выполнятся ЮЕСКОНЕЧНО!
// Так мы повесим вкладку в браузере!

// Пример 1

let r = 0

while (r < 5) {
    console.log(r)
    r+=1 // Изменение переменной r+=1, которая влияет на условие.
}

// 1. Меняем r+=1 внутри цикла, тем самым влияем на условие (r < 5)
// 2. И когда r cnfytn 5 условие станет ложно (5 < 5) и мы выйдем из цмкла.
// 3. Потому мы не видим 5 в консоле!

// Если условие правдиво, мы заходиим в цикл и выполняем блок кода.

// 0
// 1
// 2
// 3
// 4

// То есть в FOR мы в одной из начальной инструкции указываем как изменять переменную которая влияет на количество итераций.
// Зде же мы внутри цикла сами должны контролировать изменения условия.
// Иначе если не будет r+=1, в данном примере цикл будет выполнятся бесконечно!


// Пример 2


// let i = 0

// while (i < 5) {
// console.log(i)
// } // ЭТОТ КОД ПОВЕСТИТ БРАУЗЕР!!! ЦИКЛ ЗАКАЛЬЦУЕТЦА!!!!


// Это бесконечный цикл, ткого НЕ НУЖНО ДОПУСКАТЬ!!!





//////////////////////////////   ЦИКЛ DO WHILE !!!   //////////////////////////////


// DO WHILE ЦИКЛ выполнится КАК МИНИМУМ ОДИН РАЗ!!!


do {
    // Блок кода, выполяемый на каждой итерации
} while (Условие)


// Мы говорим, делать что-то пока условие ПРАВДИВО!
// А все потому что УСЛОВИЕ находится ПОСЛЕ блока кода!
// Потому такой блок инструкций выполняется хотябы один раз.

// let i = 0

// do {
//     console.log(i)
//     i+=1
// } while (i < 5)

// 0
// 1
// 2
// 3
// 4
// 5

// Мы первый раз будет смотерть на условие while (i < 5) когда i уже увеличится на еденицу, когда i станет 1.
// Когда мы напечатаем в i 5 то условие (i < 5) будет ложно после чего мы выйдем из цикла.

// Нам нужно использовать DO WHILE когда мы хотим выполнить блок кода хотябы раз.
// В данном примере блок кода выполнится хотябы один раз, после идет условие, while (i < 5) оно будет ложно, и мы выходим из цикла.

// То есть даже если условие while (i < 5) ложно, блок кода выполнится все равно один раз, так как условие находится после блока кода!



//////////////////////////////   ЦИКЛ FOR IN беребор для ОБЬЕКТА !!!   //////////////////////////////

// Использую такой цикл, мы можем перебрать все совйства ОБЬЕКТА.
for (key in Object) {
// Действия с каждым свойством обьектом
// Значечния свойства - Object[key]
}
// Ключевые слова for И in данного цикла.

// 1. key - это будет СВОЙСТВА ОБЬЕКТА!!!
// 2. Object - это переменная, значение которой это ОБЬЕКТ!!!
// 3. Эта запись Object[key] равна Object.x ответ 10. 


const myObject2 = {
x: 10,
y: true,
z: 'abc'
}

for (const key in myObject2) {
    console.log(key, myObject2[key])
}
// ( x - значение переменной key) И ( 10 - это myObject2[key] дает нам значение таво или инова свойства )
// y true
// z abc

// Блок инструкций выполняется для каждого свойства обьекта.

// 1. Мы обьявляем переменную const key в цикле FOR.
// 2. В блоке мы печатаем в консоль название свойства key это уже будет значение определенного свойства.
// 3. myObject2[key] на этой строке в переменную key подставляется свойство обьекта.
// То есть на первой итерации myObject2[key] === myObject2.x на второй итерации То есть myObject2[key] === myObject2.y и тд...
// Таким образом можно перебрать все свойства и знаяения обьекта!
// Этот кусок кода myObject2[key] можно разобрать так, myObject2 - это обьект [key] - это .x получается обратились как через точечную запись myObject2.x ответ значение 10.



//////////////////////////////   ЦИКЛ FOREACH для ОБЬЕКТА !!!   //////////////////////////////


// Использование FOREACH ДЛЯ ОБЬЕКТОВ!
const myArray15 = {
    x: 10,
    y: true,
    z: 'abc'
}

Object.keys(myArray15).forEach(key => {
    console.log(key, myArray15[key])
})

// С помощью вызова метода keys который является методом переменной Object с больщой буквы О
// Можно получить все ключи определенного обьекта в виде МАССИВА.
// 1. Эта часть Object.keys(myArray15) даст нам массив, МАССИВ СВОЙСТВ x, v, z.
// 2. Далее используя FOREACH, можем перебрать элементы этого массива.
// 3. Как в любом FOREACH мы передаем колбек функцию, у которой в данном примере один параметр key.
// 4. Далее мы печатаем в консоль ключ key, и так же как и ранее можно получить доступ к значению 
// myArray15[key] определенного свойства обьекта использую запись с квадратными [] скобками. На первой итерации myArray15[key] === myArray15.x и тд.


// Кроме этого можно перебирать сразу значение обьекта, для этого можно вызвать МЕТОД values.
// value это будет значение свойств обьекта.

const myArray16 = {
    x: 10,
    y: true,
    z: 'abc'
}

Object.values(myArray16).forEach(value => {
    console.log(value)
})
// Здесь с помощью Object.values мы выводим ТОЛЬКО ЗНАЧЕНИЕ свойств обьекта.
// Этот кусок кода Object.values(myArray16) даст на выходе МАСИВ значений свойств обьекта.
// Так как с ОБЬЕКТА мы получаем МАССИВ можно использовать FOREACH и перебрать элементы массива.

// 1. Object.keys - дает на выходе новый МАССИВ совйст и + можно вывести значение ОБЬЕКТА через myArray15[key]!
// 2. Object.values - дает на выходе новый МАССИВ значений свойств ОБЬЕКТА!


// Как легко с ОБЬЕКТА можно конвентировать в МАССИВ.

// Если нам с ОБЬЕКТА нужно получить МАССИВ СВОЙСТВ, то Object.keys хорошо подходит для этого!

const myObject3 = {
    age: 33,
    name: 'Vlad'
}

const myObgArray = Object.keys(myObject3)
// С помощью Object.keys конвентировать с СВОЙСТВ обьекта массив, значение которого будут свойства обьекта.

console.log(myObgArray)
// [ 'age', 'name' ]





// Если нам с ОБЬЕКТА нужно получить МАССИВ ЗНАЧЕНИЙ, то Object.values хорошо подходит для этого!

const myObject4 = {
    age: 33,
    name: 'Vlad'
}

const myObgArray2 = Object.values(myObject4)
// С помощью Object.values можно конвентировать ЗНАЧЕНИЕ свойств обьекта в МАССИВ.


console.log(myObgArray2)
// [ 33, 'Vlad' ]


// 1. Object.keys - дает на выходе новый МАССИВ совйст и + можно вывести значение ОБЬЕКТА через myArray15[key] с помощью ЦИКЛА!
// 2. Object.values - дает на выходе новый МАССИВ значений свойств ОБЬЕКТА!

// А так как после конвертации ОБЬЕКТА в МАССИВ на выходе МАССИВЫ, можно легко выполнять с ними действия, искать, фильтровать,
// возвращать новые массивы, перебирать циклами, доупстим циклом FOREACH.





//////////////////////////////   ЦИКЛ FOR IN для МАССИВОВ !!!   //////////////////////////////

// ЦИКЛ FOR IN не только для ОБЬЕКТОВ, им так же можно перебрать МАССИВ!


const myArray17 = [true, 10, 'abc', null]


for (const key in myArray17) {
    console.log(myArray17[key])
}

// 1. Обьявляем переменную const key.
// 2. На каждой итерации цикла, будет создаваться обсолютно новая переменная key.
// 3. Далее key будет ровно 0, потом 1, 2, 3 и тд, это индекс каждого элемента МАССИВА.
// 4. Используя синтаксис myArray17[key] где key это переменная. 

// Это то как можно перебрать элементы в массиве используя FOR IN.


// ТАК ДЕЛАТЬ НЕ РЕКОМЕНДУЕТСЯ, ДЛЯ ЭТОГО У МАССИВОВ ЕСТЬ СВОИ МЕТОДЫ forEach, map, filter, reduce.
// forEach это родной метод массивов.


//////////////////////////////   ЦИКЛ FOR OF ОН ПОЯВИЛСЯ В ES6 !!!   //////////////////////////////


// Синтаксис
for (Element of Inerable) {
// Действие с определенным элементом.
}

// 1. Inerable ЭТО любое значение или переменная которая содержит значение по которуму можно ИТЕРИРОВАТЬСЯ,
// элементы которого можно перебирать.

// Например в любой строке можно перебирать символы, любая строка это итерированна строка.
// В тком случе Element это будет символ конкретной строки.
// Это будет переменная доступна на каждой итерации цикла.


// Пример 1

const myString = 'Hey'

for (const letter of myString) {
    console.log(letter)
}
// В данном примере будет три итерации, вывод трех букв с строки.
// letter будет представлять кадый символ строки которая лежит в переменной myString.

// H
// e
// y



// Пример 2

// ЦИКЛ FOR OF для Массива.

const myArray18 = [true, 10, 'abc', null]

for (const element of myArray18) {
    console.log(element)
}

// 1. Обьявляем переменную element 
// 2. На каждой итерации такая переменная будет новая, потому мы будем использовать const.
// 3. Внутри уже цикла мы печатаем console.log(element)
// Эелементам будет каждый элемент в этом массиве.

// true
// 10
// abc
// null


// ДЛЯ МАССИВОВ ИСПОЛЬЗУЕМ FOREACH!!!!!!
const myArray19 = [true, 10, 'abc', null]

myArray19.forEach(element => {
    console.log(element)
})
// ДЛЯ МАССИВОВ ИСПОЛЬЗУЕМ FOREACH!!!!!!



/////////  ЦИКЛ FOR OF НЕ ДЛЯ ОБЬЕКТОВ ///////

// Обьект это не итерированный элемент в JS!!!!
// По причине того что для обьекта порядок свойств НЕ ВАЖЕН, FOR OF не знает в какой последовательности нужно перебирать обьект.
// Если попробовать перебрать обьект циклом for of, будет ошибка!

// Чтобы итерироваться по обьекту мы должны использовать ЛИБО FOR IN ЛИБО конвентировать ОБЬЕКТ В МАССИВ,
// использую методы Object.keys для свойств и Object.values для значений свойств.


// Помним для перебора МАССИВОВ forEach, map, indexOf, reduce и тд..
// Для ОБЬЕКТОВ есть возможность конвертации ОБЬЕКТА В МАССИВ с помощью Object.keys, получим МАССИВ СВОЙСТВ или Object.values получим МАССИВ ЗНАЧЕНИЙ СВОЙСТВ.
// А далее снова используем циклы для МАССИВОВ forEach, map, indexOf, reduce и тд..
// Для того чтобы выполнять какий-то операции с свойствами или значениями свойст обьекта.
// Это мы должны очень хорошо уметь!!! В таком случае for, while, do while нам не понадобятся!






//////////////////////////////   МОДУЛИ !!!   //////////////////////////////

// Введение

// 1. Модули позволяют структурировать код.
// 2. Модули позволяют избегать дублирование блоков кода.
// 3. Мы можем вынести какуй-то функцию в отдельный модуль, фалй JS а далее использовать эту функцию во многих других файлах.

// Синтаксис данный появился в ES6 или же 2015.

// Файл moduleOne.js это отдельный модуль -- export...
// Файл moduleTwo.js это отдельный модуль -- import...

// Допустим функцию с одного файла он же модуль мы можем експортировать "export" в другой файл он же модуль импонтировать "import"
// и потом вызовать ту функцию где мы ее импонировали.

// Таким образом мы можем связывать один модуль с другим модулем.

// C moduleOne.js сделали "export" и в другом модуле moduleTwo.js експортировали "export"
// Каждый модуль/файл это отдельная зона видимости переменных!




// Примеры!

// moduleOne.mjs
// const myName1 = () => {
// console.log('Vlad')
// }
// export default myName1



// moduleTwo.mjs
// import printMyName from './Modul/moduleOne.mjs'

// printMyName() // Vlad




//////////////////////////////   КЛАССЫ И ПРОТОТИПЫ !!!   //////////////////////////////



class Comment {
    constructor(text) {
        this.text = text
        this.votesQty = 0
    }

    upvote() {
        this.votesQty += 1
    }
}



